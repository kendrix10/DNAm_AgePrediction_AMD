---
title: "Epigenetic age in age-related macular degeneration (AMD) samples"
author: "kendrix"
date: "25/5/2020"
output:
 html_document:
      highlight: pygments
      theme: united
      toc: true
      toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Aim: To test the association between age-related macular degeneration (AMD) with epigenetic age.

Pre-processing script adapted from Chaini Konwar.


---------------------------------------------------------------------------------------------------------------------------

```{r, echo=TRUE, results='hide', warning=FALSE, message=FALSE}
library(GEOquery)
library(RCurl)
library(GEOmetadb)
library(dendextend)
library(ArrayExpress)
library(methylumi)
library(lumi)
library(lattice)
library(gplots)
library(RColorBrewer)
library(limma)
library(ROC)
library(matrixStats)
library(reshape)
library(sva)
library(grid)
library(gridExtra)
library(ape)
library(Hmisc)
library(RCurl)
library(wateRmelon)
library(minfiData)
library(minfi)
library(robustHD)
library(ewastools)
library(omicsPrint)
library(doParallel)
library(jcolors)
library(plyr)
library(tidyverse)
library(ggrepel)
library(ggpubr)
library(IlluminaHumanMethylationEPICanno.ilm10b2.hg19)
library(IlluminaHumanMethylationEPICmanifest)
library(IlluminaHumanMethylation450kanno.ilmn12.hg19)
library(IlluminaHumanMethylation450kmanifest)
library(FlowSorted.Blood.EPIC)
library(FlowSorted.Blood.450k)
library(FlowSorted.CordBloodCombined.450k)
library(Biobase)
library(data.table)
library(factoextra)
library(Metrics)
library(quantro)
library(impute)

setwd("~/KoborLab/kobor_space/kendrix/macular_degeneration/")
```

---------------------------------------------------------------------------------------------------------------------------


##Data exploration and object creation


###Step 1: Explore data downloaded from ArrayExpress.

The data used here comes from [Whole-genome methylation profiling of the retinal pigment epithelium of individuals with age-related macular degeneration reveals differential methylation of the SKI, GTF2H4, and TNXB genes by *Porter et al.*](https://clinicalepigeneticsjournal.biomedcentral.com/articles/10.1186/s13148-019-0608-2#rightslink).

The authors made the dataset publicly available in ArrayExpress with the Accession number: E-MTAB-7183.

The dataset consists of ocular tissue (pigmented layer of retina) from 25 AMD samples (21 level 2 AMD and 4 level 3 AMD) and 19 controls.

The age ranges from 50 years old to 89 years old, and the sex distribution is as follows: Male (27), Female (17).

```{r, results='hide'}
#Explore metadata.
AMD_meta <- read.table("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/E-MTAB-7183_meta.txt", sep = "\t", header = TRUE)
colnames(AMD_meta)[1] <- "Sample_Name"
colnames(AMD_meta)[3] <- "Sex"
colnames(AMD_meta)[4] <- "Age"
colnames(AMD_meta)[6] <- "Tissue"
colnames(AMD_meta)[7] <- "Disease_state"
colnames(AMD_meta)[17] <- "Assay_name"

AMD_meta$Sex <- gsub("male", "M", gsub("female", "F", AMD_meta$Sex)) #Changed for easier comparison with minfi sex prediction. 

#Create samplesheet.
AMD_samplesheet <- AMD_meta[, c("Sample_Name", "Disease_state", "Assay_name", "Sex", "Age", "Tissue")]
colnames(AMD_samplesheet)[2] <- "Sample_Group"
AMD_samplesheet$Assay_name <- gsub("_Grn", "", gsub("_Red", "", AMD_samplesheet$Assay_name))
AMD_samplesheet <- separate(AMD_samplesheet, col = "Assay_name", sep = "_", into = c("Sentrix_ID", "Sentrix_Position"))

duplicated(AMD_samplesheet) #The samplesheet contains duplicated samples. 
AMD_samplesheet <- AMD_samplesheet[duplicated(AMD_samplesheet),] #Remove duplicated samples. 
```

```{r, eval=FALSE}
write.csv(AMD_samplesheet, file = "~/KoborLab/kobor_space/kendrix/macular_degeneration/data/idats/AMD_project/AMD_samplesheet.csv", row.names = FALSE)
```


###Step 2: Create ExtendedRGSet object.

```{r, results='hide', message=FALSE}
path = "~/KoborLab/kobor_space/kendrix/macular_degeneration/data/idats/AMD_project"
targets <- read.metharray.sheet(path) #Tells R to look for sample sheet within the folder. 
baseDir <- system.file(path, package = "minfiData") 
baseDir #baseDir determines the array chip position and ID.
sub(baseDir, "", targets$Basename) #The class of RGSet is an RGChannelSet object. This is the initial object of a minfi analysis that contains the raw intensities in the green and red channels. Note that this object contains the intensities of the internal control probes as well.

#Create Extended RGSet object.
AMD_ExtendedRGSet <- read.metharray.exp(targets = targets, extended = TRUE, verbose = TRUE)
AMD_ExtendedRGSet
```

```{r}
sampleNames(AMD_ExtendedRGSet) == paste0(AMD_samplesheet$Sentrix_ID, "_", AMD_samplesheet$Sentrix_Position) #Check order of sampleNames in RGSet and samplesheet to change sampleNames in RGSet. Proceed ONLY if all is TRUE. 
sampleNames(AMD_ExtendedRGSet) <- AMD_samplesheet$Sample_Name #Change sampleNames of AMD_ExtendedRGSet.
identical(sampleNames(AMD_ExtendedRGSet), rownames(pData(AMD_ExtendedRGSet))) #Confirm sample orders in pData.
identical(sampleNames(AMD_ExtendedRGSet), colnames(getBeta(AMD_ExtendedRGSet))) #Confirm sample orders in beta matrix. 
```

```{r, eval=FALSE}
save(AMD_ExtendedRGSet, file = "~/KoborLab/kobor_space/kendrix/macular_degeneration/data/AMD_ExtendedRGSet.RData")
```


###Step 3: Create ewastools object.

```{r}
#Create ewastools sampleInfo sheet.
AMD_sampleInfo <- AMD_meta[,c("Sample_Name", "Disease_state", "Assay_name", "Sex", "Age", "Tissue")]
AMD_sampleInfo$Assay_name <- gsub("_Red", "", gsub("_Grn", "", AMD_sampleInfo$Assay_name))
AMD_sampleInfo <- unique(AMD_sampleInfo) #Remove duplicates. 
path <- "/home/BCRICWH.LAN/kendrix.kek/KoborLab/kobor_space/kendrix/macular_degeneration/data/idats/AMD_project/"
AMD_sampleInfo$Assay_name <- paste0(path, AMD_sampleInfo$Assay_name)
meth <- read_idats(AMD_sampleInfo$Assay_name, quiet = TRUE)

rm(AMD_meta) #Remove original meta file. 
```

```{r, eval=FALSE}
save(AMD_sampleInfo, meth, file = "~/KoborLab/kobor_space/kendrix/macular_degeneration/data/AMD_ewastools_object.RData")
```


---------------------------------------------------------------------------------------------------------------------------


##Quality Control - Sample Filtering


###Step 1: Load objects.

```{r}
load("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/AMD_ExtendedRGSet.RData")
load("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/AMD_ewastools_object.RData")

AMD_samplesheet <- read.csv("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/idats/AMD_project/AMD_samplesheet.csv", header = TRUE)
```


###Step 2: Detection p-value.

It is worth checking the quality of the samples to see if they are true signals and are not conflated with background noise. One way to do so is by determining the detection p-values of the samples to parse out true methylation signals. Detection p-values by definition are measures that differentiate sample signal from background noise (which is estimated using the negative probes of the array). By default, the threshold for significant detection p-value is set at 0.01. Samples that are above the p-value threshold are considered statistically poor and should be removed (i.e. samples with high detection p-value should be discarded because they were detected with **low signal-to-noise ratio of fluorescence intensities**).

The minfi package provides a function, detectionP() to determine detection p-values for each methylation region across samples using the negative control probes in the array that are designed to NOT target the human genome. The probe sequences are propriety and are suggested to feature very low intensities (Heiss & Just (2019)).

NOTE: No samples above detection p-value of 0.01. All samples passed. 

```{r, fig.align='center'}
detp_minfi <- minfi::detectionP(AMD_ExtendedRGSet) #Detection p-value distinguishes signal from background noise with a single cut-off.
head(detp_minfi)[,1:5]

#Examine mean detection p-values across all samples to identify any failed samples.
plot(colMeans(detp_minfi), ylim = c(0.00002, 0.05), xaxt = 'n', ann = FALSE, pch = 20, col = "black", cex = 1) + 
  mtext(side = 1, line = 0.5, "Samples", font = 1, cex = 1) + 
  mtext(side = 2, line = 2, "Mean detection p-values", font = 1, cex = 1) + 
  abline(h = 0.01, col = "red") + 
  text(colMeans(detp_minfi), labels = AMD_ExtendedRGSet$Sample_Name, cex = 0.5, font = 2, pos = 2)
```

Heiss and Just recommends using the non-specific fluorescence intensities to estimate the background signal, which is a more accurate and stringent method without needing to set an extreme detection p-value cut-off. They imply that this method not only "protect against false-positive findings" but "against false-negative findings as well". They show that their method calls almost all Y-chromosome probes among males, but classifies most Y-chromosome probes in females as undetected using the 0.01 cut-off, which is the intended outcome as females possess XX chromosomes and should not have any signal detected in Y-chromosomes. They also show similar results detected using the negative control probes, but with a more extreme cut-off and more samples filtered (> 1e-40).

NOTE: No samples above detection p-value of 0.01. All samples passed.

```{r, fig.align='center'}
detp_ewastools <- ewastools::detectionP(meth) #Detection p-value distinguishes signal from background noise with a single cut-off.
detp <- as.data.frame(detp_ewastools$detP)
head(detp)[,1:5]
colnames(detp) <- colnames(getBeta(AMD_ExtendedRGSet))
rownames(detp) <- meth$manifest$probe_id

#Examine mean detection p-values across all samples to identify any failed samples.
plot(colMeans(detp, na.rm = TRUE), ylim = c(0.00002, 0.05), xaxt = 'n', ann = FALSE, pch = 20, col = "black", cex = 1) + 
  mtext(side = 1, line = 0.5, "Samples", font = 1, cex = 1) + 
  mtext(side = 2, line = 2, "Mean detection p-values", font = 1, cex = 1) + 
  abline(h = 0.01, col = "red") + 
  text(colMeans(detp, na.rm = TRUE), labels = colnames(detp), cex = 0.5, font = 2, pos = 2)
```


###Step 3: Beadcount.

For each probe sequence in the 450K array, a median of 14 beads is randomly distributed on the array. Each of these beads contains hundreds of thousands of oligonucleotides. This provides a unique set of internal technical replication on each array. This step is done to remove probes that are not represented by a minimum of 3 beads on the array, which is important to correct for positional effects (i.e. the effects where the same sample in different physical positions on the array could be measured as different methylation levels).

Probes that are not represented by a minimum of 3 beads on the array are designated as NA with the beadcount() function.

NOTE: All samples passed. 

```{r, fig.align='center'}
#Calculate the number of samples with bead count <3 for each probe in a matrix of bead count values.
bead <- beadcount(AMD_ExtendedRGSet)
colnames(bead) <- gsub('X', '', colnames(bead))

AMD_samplesheet <- AMD_samplesheet %>% mutate(Beadcount = colSums(is.na(bead)))

AMD_samplesheet %>% 
  mutate(Sample_Name = factor(as.character(Sample_Name), levels = Sample_Name)) %>%
  ggplot(aes(x = Sample_Name, y = Beadcount)) +
  geom_point(alpha = 0.7, color = 'black') + 
  geom_hline(yintercept = 0.01*nrow(bead), linetype = 'dashed', color = 'green') +
  geom_text(aes(x = 0, y = 0.01*nrow(bead)), 
            label = '1%', vjust = -0.5, hjust = -0.5, color = 'green')+
  scale_y_continuous(limits = c(0, 12500), breaks = seq(0, 12500, 2500)) +
  labs(x = 'Samples', y = '', title = '# Samples with probes with bead count < 3') +
  theme_classic() +
  theme(axis.text.x = element_blank()) 
```

```{r}
save(detp_minfi, bead, file = "~/KoborLab/kobor_space/kendrix/macular_degeneration/data/AMD_detp_beadcount_QC.RData")
```


###Step 4: Log median intensity of methylated and unmethylated channels.

minfi package provides a simple quality control plot that uses the log median intensity in both the methylated (M) and unmethylated (U) channels. When plotting these two medians against each other, it has been observed that good samples cluster together with higher median intensities, while failed samples tend to separate and have lower median intensities.

NOTE: All samples passed. 

```{r, fig.align='center'}
AMD_MSet <- preprocessRaw(AMD_ExtendedRGSet) #Get MSet object from RGSet.
head(getMeth(AMD_MSet)[,1:3])
head(getUnmeth(AMD_MSet)[,1:3])

AMD_QC <- getQC(AMD_MSet)
head(AMD_QC)
plotQC(AMD_QC)
```


###Step 5: Control metrics.

Quality control metrics are examined to determine the success of the bisulphite conversion and subsequent array hybridisation. This check uses the Illumina’s 636 control probes to assess technical parameters including array staining, extension, hybridization, target removal, specificity, and bisulfite conversion.

NOTE: All samples passed control metrics. 

```{r}
ctrls <- control_metrics(meth)
# A logical vector of passed/failed is returned by sample_failure() which compares all 17 metrics against the thresholds recommended by Illumina.

AMD_sampleInfo$failed <- as.data.frame(sample_failure(ctrls))
table(AMD_sampleInfo$failed) #If AMD_sampleInfo$failed == FALSE, all samples PASS.

failed_control_metrics <- AMD_sampleInfo[AMD_sampleInfo$failed == TRUE, "Sample_Name"] #Check the sample names for the ones that fail control metrics.
failed_control_metrics #No failed samples. 

#Summary of control metrics.
control_metrics_all <- as.data.frame(ctrls)
control_metrics_all$Sample_Name <- AMD_sampleInfo$Sample_Name
head(control_metrics_all)
sapply(control_metrics_all, function(x) sum(is.na(x)))
```

```{r, fig.align='center'}
stripchart(ctrls$`Bisulfite Conversion II`, method = "jitter", pch = 4, xlab = 'Bisulfite Conversion II', xlim = c(0,20)) + 
  abline(v = 1, col = 2, lty = 3) +
  text(ctrls$`Bisulfite Conversion II`[ctrls$`Bisulfite Conversion II` < 1], 1.2, labels = ctrls$Sample_Name[ctrls$`Bisulfite Conversion II` < 1], srt = 45)
```

or

```{r, fig.align='center'}
controlStripPlot(AMD_ExtendedRGSet, controls = c("BISULFITE CONVERSION I", "BISULFITE CONVERSION II"))
```


###Step 6: Contamination check.

The 450K BeadChip also features 65 control probes which assay highly-polymorphic single nucleotide polymorphisms (SNPs) rather than DNA methylation. These are included on the array to allow sample quality control to check for relatedness between individuals and enable the detection of potential sample mix-ups. The signal from these probes is expected to cluster into three distinct groups (representing the heterozygous and two homozygous groups). The snp_outliers function however computes the average log odds from the 65 posterior probabilities from a mixture model to capture how irregular the SNP betas are, i.e. how much they deviate from the ideal trimodal distribution. Although these are not DNA methylation signals, they could be used to provide an indication of the degree of technical variance between samples. 

NOTE: All samples passed. 

```{r, fig.align='center'}
#While ewastools implements the LOESS normalization (Heiss and Brenner, 2015), the developers of the package says not use the normalization "as it does little to protect against batch effects but can result in the removal of genuine biological signal". They recommend to adjust for relevant technical covariates in regression models later.

beta <- dont_normalize(meth)

#Pulling SNP probes.
snps <- meth$manifest[probe_type == "rs", index]
snps <- beta[snps,]

#These SNPs are then used as input for call_genotypes(). This function estimates the parameters of a mixed model consisting of three beta distributions representing one heterozygous and the two homozygous genotypes. There is also a fourth component, shown as a uniform distribution that represents outliers. The functions returns posterior probabilities used for soft classification. 
#In simple words, we are determining the probability for every SNP whether they belong to 1 of 4 different distributions - 3 of which correspond to the 3 expected genotypes (AA, AB, BB), and the 4th distribution corresponds to outside/in-between these expected genotype distributions. SNPs with a higher probability of belonging to this 4th distribution indicate mixing between more than one genotype.

#Fit mixed model to call genotypes.
genotypes_called <- call_genotypes(snps, learn = T)

#Call genotype clusters.
AMD_samplesheet <- AMD_samplesheet %>% 
  mutate(genotype_cluster = as.factor(enumerate_sample_donors(genotypes_called)))

#Examine probability outlier.
plot(snp_outliers(genotypes_called) %>% sort, ylab = "SNP Outliers")

#Overall distribution of the genotypes.
ewastools:::mxm_(genotypes_called)
```

We see 3 peaks, corresponding to 3 possible genotypes.

```{r, fig.align='center'}
#Check the average probability of SNP not belonging to any of the 3 genotypes (coloured by Sex).
AMD_samplesheet <- AMD_samplesheet %>% 
  mutate(Prob_SNP_outlier = colMeans(genotypes_called$outliers, na.rm = T),
         Prob_SNP_outlier_Logodds = snp_outliers(genotypes_called))
  
  ggplot(AMD_samplesheet, aes(x = Sample_Name, y = Prob_SNP_outlier, fill = Sex)) +
  geom_point(shape = 21, size = 2.5, alpha = 0.8, col = "black") + 
  scale_fill_manual(values = c("#bd7b9f", "#2c7dab")) +
  labs(x = 'Samples', y = "Probability", 
       title = 'Average probability of SNP being an outlier') +
  theme_bw() +
  theme(axis.text.x = element_text(size = 14),
        axis.text.y = element_text(size = 14),
        axis.title.x = element_text(size = 15, vjust = -0.3),
        axis.title.y = element_text(size = 15, vjust = 2),
        legend.position = "none") +
  scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, 0.1)) +
  scale_x_discrete(breaks = NULL, expand = c(0.02, 0.02))
```

The Y-axis denotes the average probability of SNP being an outlier. No sample appears to be > 0.1 probability, indicating that there is minimal probability of the presence of outlier.

```{r, fig.align='center'}
#Look at the raw distribution
snp_betas <- getSnpBeta(AMD_ExtendedRGSet)
snp_betas_melt <- t(snp_betas) %>% as_tibble %>% mutate(Sample_Name = colnames(snp_betas)) %>%
  left_join(AMD_samplesheet %>% select(Sample_Name, Sex), by = 'Sample_Name') %>%
  gather(key = 'SNP', value = 'Beta', -Sample_Name, -Sex)

ggplot(snp_betas_melt, aes(x = SNP, y = Beta, fill = Sex)) +
  geom_point(shape = 21, size = 2.5, alpha = 0.8, col = "black") + 
  scale_fill_manual(values = c("#bd7b9f", "#2c7dab")) +
  labs(x = '59 SNPs') + theme_bw() + theme(axis.text.x = element_blank()) +
  theme_bw() +
  theme(axis.text.x = element_blank()) +
  scale_x_discrete(breaks = NULL, expand = c(0.02, 0.02))
```


###Step 7: Data linkage errors and Sample relations detection.

omicsPrint (Van Iterson et al. 2018) is a package developed to detect data linkage errors through inspecting sample relations in multiple omics studies. Included with the package is the hm450.manifest.pop.GoNL data, which stores SNP probe information in a GRanges class object. This is then used to create a subset of the beta values for genotyping. The function beta2genotype() then genotypes the observations by measuring homozygous or heterozygous alleles at these SNP probes. Lastly alleleSharing() assesses the relationships between different individuals, which can be unrelated, twins, or identical. The results can then be visualised using the inferRelations() function. In the data with sample relationships, this would be shown in the above graph as green or black clusters (Van Iterson et al. 2018). It is important to carry out this type of visualization before probe-filtering as otherwise the genotyping will be based on very few SNPs.

NOTE: No mismatches found. 

```{r, fig.align='center'}
data(hm450.manifest.pop.GoNL)

betas <- getBeta(AMD_ExtendedRGSet)

cpgs <- names(hm450.manifest.pop.GoNL[mcols(hm450.manifest.pop.GoNL)$MASK.snp5.EAS])
cpgs <- na.omit(match(cpgs, rownames(betas)))
omicsBetas <- betas[cpgs,]
omicsBetas[1:10, 1:2]

dnamCalls <- beta2genotype(omicsBetas, assayName = "exprs")
dim(dnamCalls)
dnamCalls[1:10, 1:2]

omicsData <- alleleSharing(dnamCalls, verbose = TRUE)
mismatches <- inferRelations(omicsData)
dim(mismatches)
```


###Step 8: Sample identity. 

Hierarchical clustergram across all samples cluster similar samples together while samples that are different from all the other samples are pulled down as outliers. 

NOTE: No obvious sample that is pulled down as outlier.

```{r, fig.align='center'}
#Use SNP probes to infer identity and see how they cluster. 
snp_betas <- getSnpBeta(AMD_ExtendedRGSet)

identity_dendo <- dist(t(snp_betas))
clust <- hclust(identity_dendo)
dendo <- as.dendrogram(clust)   

dendo %>% dendextend::set("labels_cex", 0.6) %>% 
  hang.dendrogram %>% plot()
```


###Step 9: Outlier detection.

The outlyx function takes any beta matrix (preferably raw) and will identify any samples that are inconsistent with the rest of the data. From the plot, we can observe that any data points that fall into the red squares are indeed outlying and should be removed from analysis.

To confirm the previous identity dendrogram with no obvious outliers, I run the chunk below to see if there are any sample that falls within the two red squares in the plot.

NOTE: No samples fall into the red squares, so no outlier confirmed.

```{r, fig.align='center'}
betas <- getBeta(AMD_ExtendedRGSet)
detout <- outlyx(betas)

detout$Sample_Name <- rownames(detout)
detout[which(detout$outliers == T),]
```


###Step 10: Sex check.

minfi has a sex predictor function that uses the median values of measurements on the X and Y chromosomes respectively. If yMed - xMed is less than cutoff of -2, the sample is predicted as female; otherwise it is predicted as male.

```{r, fig.align='center'}
#Sex prediction using minfi's getSex() function. 
AMD_gRSet <- mapToGenome(AMD_MSet) #Convert to GenomicMethylSet object. 
predSex <- getSex(AMD_gRSet)
head(predSex)

#Compare to Sex from metadata. 
AMD_samplesheet$Sex <- as.factor(AMD_samplesheet$Sex)
predSex$predictedSex <- as.factor(predSex$predictedSex)
all.equal(AMD_samplesheet$Sex, predSex$predictedSex) #TRUE.

#Plot predicted sex against reported sex from metadata.
predictedSex <- as.data.frame(predSex)
ggplot(predictedSex, aes(x = xMed, y = yMed, fill = AMD_samplesheet$Sex)) +
  geom_point(shape = 21, size = 3, alpha = 0.8, col = "black") +
  scale_fill_manual(values = c("#bd7b9f", "#2c7dab")) +
  theme_classic() +
  theme(axis.text.x = element_text(size = 14),
        axis.text.y = element_text(size = 14),
        axis.title.x = element_text(size = 15, vjust = -0.3),
        axis.title.y = element_text(size = 15, vjust = 2),
        legend.position = "none")
```

The sex of the samples cluster accordingly.

ewastools has a similar sex predictor function that computes for each sample the average total intensities of all probes targeting either chromosome, X and Y respectively (There are 11,232 probes that target the X chromosome and 413 probes that target the Y chromosome). This function exploits the natural difference in allosomal (sex) copy number (with females having more copy number than males) and the fact that total intensity (U + M) is sensitive to copy number variation to detect sex mismatches. The threshold to discriminate between both sexes is determined by the Hodges-Lehmann estimator (i.e. median of all pairwise male/female averages) for X and Y chromosomes separately. The dotted lines in the figure below represent the Hodges-Lehman estimators separating the male and female cluster centres. The male samples should cluster in the top left quadrant while the female samples should cluster in the bottom right quadrant. The samples that fall in the top right and bottom left quadrants are considered "unclear" (Heiss & Just 2018).

It is suggested that this approach is more robust than minfi’s getSex() function due to its potential to detect sex mismatches and allosomal outliers.

```{r, fig.align='center'}
#Sex prediction using ewastools' check_sex() function. 
predicted_sex <- check_sex(meth)
AMD_samplesheet <- AMD_samplesheet %>% mutate(normalized_X_intensity = predicted_sex$X,
                        normalized_Y_intensity = predicted_sex$Y)

#Sex plot.
ggplot(AMD_samplesheet, aes(x = normalized_X_intensity, y = normalized_Y_intensity, fill = Sex)) +
  geom_point(shape = 21, size = 3, alpha = 0.8, col = "black") + theme_classic() +
  scale_fill_manual(values = c("#bd7b9f", "#2c7dab")) +
  geom_text_repel(data = AMD_samplesheet %>% filter(Sex == 'M', normalized_X_intensity > 0.95,
                                         normalized_Y_intensity < 0.5), 
                  aes(label = Sample_Name), size = 3, force = 15, nudge_x = -0.1, nudge_y = -0.1) +
  geom_hline(yintercept = 0.5, linetype = 'dashed', col = '#bd7b9f') + 
  geom_vline(xintercept = 0.95, linetype = 'dashed', col = '#2c7dab') +
  theme(axis.text.x = element_text(size = 14),
        axis.text.y = element_text(size = 14),
        axis.title.x = element_text(size = 15, vjust = -0.3),
        axis.title.y = element_text(size = 15, vjust = 2),
        legend.position = "none")
```

This second check confirms no sex mismatches in the samples.


###Step 11: Post sample filtering PCA.

Code from Nicole Gladish, Rachel Edgar and Sumaiya Islam.

Location: ~/KoborLab/kobor_space/shared_coding_resource/PCA Code.Rmd

```{r}
betas <- getBeta(AMD_ExtendedRGSet) #Essentially use your mvalue matrix.
meta <- pData(AMD_ExtendedRGSet)
PCA_full <- princomp(na.omit(betas)) #You can't have NAs in your dataframe - make sure to either remove probes with a lot of NAs and/or have imputed values. Can run na.omit but depending on the stage of pre-processing, could result in a lot of probes to be removed and a very inaccurate PCA.
Loadings <- as.data.frame(unclass(PCA_full$loadings))
vars <- PCA_full$sdev^2
Importance <- vars/sum(vars)
adjust <- 1-Importance[1]
pca_adjusted <- Importance[2:length(Importance)]/adjust
pca_df <- data.frame(adjusted_variance = pca_adjusted, PC = seq(1:length(pca_adjusted)))

#Restructure meta so that variables are in the appropriate format - categorical variables (sex is commonly labelled as 0 and 1) are factors and not numeric for example.

colnames(meta)[6] <- "Sentrix_Position"
colnames(meta)[7] <- "Sentrix_ID"

meta$Sentrix_ID <- as.factor(meta$Sentrix_ID)
meta$Sentrix_Position <- as.factor(meta$Sentrix_Position)
meta$Sex <- as.factor(meta$Sex)
meta$Sample_Group <- as.factor(meta$Sample_Group)
meta$Age <- as.numeric(meta$Age)

colnames(meta) #Obtain the column numbers to include.
meta_categorical <- data.frame(meta[, c(2,3,6,7)])  #Input column numbers in meta that contain categorical variables.
meta_continuous <- data.frame(meta[,4])  #Input column numbers in meta that contain continuous variables.
colnames(meta_categorical) #Write the line below to ensure you're changing the names of your variables in the right order.
colnames(meta_categorical) <- c("Disease state", "Sex", "Row", "Chip")
colnames(meta_continuous)
colnames(meta_continuous) <- c("Age")

Order <- c(seq(1:sum(ncol(meta_categorical), ncol(meta_continuous))))
Num <- 16 #This number will depend on your dataset - if you only have 6 samples, you should probably only show 5 PCs or less.
```

```{r, warning=FALSE, message=FALSE, fig.align='center', fig.height=7, fig.width=8}
#Run PCA.
source("~/KoborLab/kobor_space/kendrix/R_Functions/heat_scree_plot.R", local = knitr::knit_global())
heat_scree_plot(Loadings, Importance, Num, Order)
```


---------------------------------------------------------------------------------------------------------------------------


##Normalisation


###Step 1: Visualise pre-normalised distribution of beta values.

```{r, fig.align='center'}
AMD_MSet <- preprocessRaw(AMD_ExtendedRGSet) #Get MSet object from RGSet.
plotBetasByType(AMD_MSet[,1])
```


###Step 2: Perform GenomeStudio normalisation.

```{r, fig.align='center'}
#Perform background correction.
AMD_MSet.illumina <- preprocessIllumina(AMD_ExtendedRGSet, bg.correct = TRUE,
                               normalize = "control")

#Plot to visualise post-normalisation distribution. 
plotBetasByType(AMD_MSet.illumina[,1])
```


###Step 3: Perform SWAN normalisation.

Subset-quantile within array normalization (SWAN) (Jovana Maksimovic, Lavinia Gordon, and Alicia Oshlack 2012) is a within-array normalization correction for the technical differences between the Type I and Type II array designs. The algorithm matches the beta-value distributions of the Type I and Type II probes by applying a within-array quantile normalization separately for different subsets of probes (divided by CpG content).

```{r, fig.align='center'}
AMD_MSet <- preprocessRaw(AMD_ExtendedRGSet) #Get MSet object from RGSet.

#SWAN uses a random subset of probes to do the between array normalization. In order to achive reproducible results, the seed needs to be set using set.seed.
set.seed(100)

#Perform SWAN normalisation.
AMD_MSet.swan <- preprocessSWAN(AMD_ExtendedRGSet, mSet = AMD_MSet)

#Plot to visualise post-normalisation distribution.
plotBetasByType(AMD_MSet.swan[,1])
```

```{r, eval=FALSE}
save(AMD_MSet.swan, file = "~/KoborLab/kobor_space/kendrix/macular_degeneration/data/AMD_MSet.swan.RData")
```


###Step 4: Perform quantile normalisation.

This function implements stratified quantile normalization preprocessing. The normalization procedure is applied to the Meth and Unmeth intensities separately. The distribution of type I and type II signals is forced to be the same by first quantile normalizing the type II probes across samples and then interpolating a reference distribution to which we normalize the type I probes. Since probe types and probe regions are confounded and we know that DNAm distributions vary across regions we stratify the probes by region before applying this interpolation. Note that this algorithm relies on the assumptions necessary for quantile normalization to be applicable and thus is not recommended for cases where global changes are expected such as in cancer-normal comparisons.

The different arguments for the function can be summarized into the following list:

If fixOutliers is TRUE, the functions fixes outliers of both the methylated and unmethylated channels when small intensities are close to zero.

If removeBadSamples is TRUE, it removes bad samples using the QC criterion discussed previously.

Performs stratified subset quantile normalization if quantileNormalize = TRUE and stratified = TRUE.

Predicts the sex (if not provided in the sex argument) using the function getSex and normalizes males and females separately for the probes on the X and Y chromosomes.

```{r, fig.align='center'}
#Perform quantile normalisation.
AMD_gRSet.quantile <- preprocessQuantile(AMD_ExtendedRGSet, 
                                     fixOutliers = TRUE, 
                                     removeBadSamples = TRUE, badSampleCutoff = 10.5, 
                                     quantileNormalize = TRUE, stratified = TRUE, 
                                     mergeManifest = FALSE, sex = NULL)

#Get manifest information for plot.
probeTypes <- data.frame(Name = featureNames(AMD_gRSet.quantile),
                         Type = getProbeType(AMD_gRSet.quantile))

#Plot to visualise post-normalisation distribution. 
betas.quantile <- getBeta(AMD_gRSet.quantile)
plotBetasByType(betas.quantile[,1], probeTypes = probeTypes)
```


###Step 5: Perform noob normalisation.

```{r, fig.align='center'}
#Perform noob normalisation. 
AMD_MSet.noob <- preprocessNoob(AMD_ExtendedRGSet)

#Plot to visualise post-normalisation distribution. 
plotBetasByType(AMD_MSet.noob[,1])

save(AMD_MSet.noob, file = "~/KoborLab/kobor_space/kendrix/macular_degeneration/data/AMD_MSet.noob.RData")
```


###Step 6: Perform BMIQ normalisation.

BMIQ normalisation uses quantiles to normalise the Type II probe values into a distribution comparable to the Type I probes using a beta-mixture model fit ot the Type I and Type II probes separately and then transforms the probabilities of class membership of the Type II probes into quantiles of beta values using the parameters of the beta-distributions of the Type I distribution. This method uses a three-state beta-mixture model but does not use fit to the middle 'hemi-methylated' component in the normalisation, therefore it does not require a trimodal distribution. The advantage of BMIQ is that it avoids selecting subsets of probes matched for biological characteristics as done in SWAN and quantile normalisation, and was found to be the best algorithm for reducing probe design bias. However, it is also a more aggressive method of normalisation, so in the attempt to make the Type II probe values more similar to the Type I probe values, it may have inadvertently remove biologically meaningful values from the distributions. 

```{r, eval=FALSE}
#Perform BMIQ normalisation.
betas.BMIQnoob <- BMIQ(AMD_MSet.noob, nfit = 100000)

#Save BMIQ object. 
save(betas.BMIQnoob, file= "~/KoborLab/kobor_space/kendrix/macular_degeneration/data/betas.BMIQnoob.RData")
```

```{r, fig.align='center'}
load("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/betas.BMIQnoob.RData")

#Plot to visualise post-normalisation distribution.
#Download 450K manifest from shared coding space.
load("~/KoborLab/kobor_space/shared_coding_resource/HM450_fdat.RData")
dim(fData_450)

#Check if the CpGs correspond with the CpGs from the manifest.
manifest <- fData_450[rownames(fData_450)%in%rownames(betas.BMIQnoob),]
dim(manifest)

#Subset data based on probe types - Either Type 1 or Type 2. 
probe_types <- fData_450$INFINIUM_DESIGN_TYPE

#Subset Type 1 probe data. 
type_1 <- subset(fData_450, fData_450$INFINIUM_DESIGN_TYPE == "I")
dim(type_1)

#See how many Type 1 CpGs correspond with the Type 1 probe data.  
type_1betas <- betas.BMIQnoob[rownames(betas.BMIQnoob)%in%rownames(type_1),]
dim(type_1betas)

#Subset Type 2 probe data. 
type_2 <- subset(fData_450, fData_450$INFINIUM_DESIGN_TYPE == "II")
dim(type_2)

#See how many Type 2 CpGs correspond with the Type 2 probe data. 
type_2betas <- betas.BMIQnoob[rownames(betas.BMIQnoob)%in%rownames(type_2),]
dim(type_2betas)

#Plot BMIQ normalised data.
plot(c(0,1), c(0,10), xlab = "Beta values", ylab = "Density", main = "")
lines(density(na.omit(type_1betas)), col = "red", lty = 2, lwd = 2)
lines(density(na.omit(type_2betas)), col = "blue", lty = 1, lwd = 2)
legend("top", inset = 0.05, cex = 1.0, c("Type 1", "Type 2"), col = c("red", "blue"), lty = c(2,1), horiz = FALSE)
```


###Step 7: Perform funnorm normalisation.

The function preprocessFunnorm implements the functional normalization algorithm developed in Jean-Philippe Fortin et al. 2014. Briefly, it uses the internal control probes present on the array to infer between-array technical variation. It is particularly useful for studies comparing conditions with known large-scale differences, such as cancer/normal studies, or between-tissue studies. It has been shown that for such studies, functional normalization outperforms other existing approaches (Jean-Philippe Fortin et al. 2014). By default, the function applies the preprocessNoob function as a first step for background substraction, and uses the first two principal components of the control probes to infer the unwanted variation.

```{r, fig.align='center'}
#Perform funnorm normalisation.
AMD_gRSet.funnorm <- preprocessFunnorm(AMD_ExtendedRGSet)

#Get manifest information for plot.
probeTypes <- data.frame(Name = featureNames(AMD_gRSet.funnorm),
                         Type = getProbeType(AMD_gRSet.funnorm))

#Plot to visualise post-normalisation distribution. 
betas.funnorm <- getBeta(AMD_gRSet.funnorm)
plotBetasByType(betas.funnorm[,1], probeTypes = probeTypes)
```

```{r, eval=FALSE}
save(AMD_gRSet.funnorm, file = "~/KoborLab/kobor_space/kendrix/macular_degeneration/data/AMD_gRSet.RData")
```


###Step 8: Post-normalisation PCA. 

Here, I am performing PCA on **funnorm** normalised betas.

```{r}
#Load the normalised beta matrix of choice.
betas <- betas.funnorm

meta <- pData(AMD_gRSet.funnorm)
PCA_full <- princomp(betas) #You can't have NAs in your dataframe - make sure to either remove probes with a lot of NAs and/or have imputed values. Can run na.omit but depending on the stage of pre-processing, could result in a lot of probes to be removed and a very inaccurate PCA.
Loadings <- as.data.frame(unclass(PCA_full$loadings))
vars <- PCA_full$sdev^2
Importance <- vars/sum(vars)
adjust <- 1-Importance[1]
pca_adjusted <- Importance[2:length(Importance)]/adjust
pca_df <- data.frame(adjusted_variance = pca_adjusted, PC = seq(1:length(pca_adjusted)))

#Restructure meta so that variables are in the appropriate format - categorical variables (sex is commonly labelled as 0 and 1) are factors and not numeric for example.

colnames(meta)[6] <- "Sentrix_Position"
colnames(meta)[7] <- "Sentrix_ID"

meta$Sentrix_ID <- as.factor(meta$Sentrix_ID)
meta$Sentrix_Position <- as.factor(meta$Sentrix_Position)
meta$Sex <- as.factor(meta$Sex)
meta$Sample_Group <- as.factor(meta$Sample_Group)
meta$Age <- as.numeric(meta$Age)

colnames(meta) #Obtain the column numbers to include.
meta_categorical <- data.frame(meta[, c(2,3,6,7)])  #Input column numbers in meta that contain categorical variables.
meta_continuous <- data.frame(meta[,4])  #Input column numbers in meta that contain continuous variables.
colnames(meta_categorical) #Write the line below to ensure you're changing the names of your variables in the right order.
colnames(meta_categorical) <- c("Disease state", "Sex", "Row", "Chip")
colnames(meta_continuous)
colnames(meta_continuous) <- c("Age")

Order <- c(seq(1:sum(ncol(meta_categorical), ncol(meta_continuous))))
Num <- 16 #This number will depend on your dataset - if you only have 6 samples, you should probably only show 5 PCs or less.
```

```{r, warning=FALSE, message=FALSE, fig.align='center', fig.height=7, fig.width=8}
#Run PCA.
source("~/KoborLab/kobor_space/kendrix/R_Functions/heat_scree_plot.R", local = knitr::knit_global())
heat_scree_plot(Loadings, Importance, Num, Order)
```


###Step 9: Sanity check.

```{r, fig.align='center'}
#Get raw betas to compare.
betas.raw <- getBeta(AMD_ExtendedRGSet)

#Check sample order for sample-sample correlation.
identical(rownames(betas.raw), rownames(betas.funnorm)) #FALSE.
identical(colnames(betas.raw), colnames(betas.funnorm)) #TRUE.

#Reorder probe order.
betas.raw <- betas.raw[order(rownames(betas.raw)),]
betas.funnorm <- betas.funnorm[order(rownames(betas.funnorm)),]

#Recheck sample order for sample-sample correlation.
identical(rownames(betas.raw), rownames(betas.funnorm)) #TRUE.
identical(colnames(betas.raw), colnames(betas.funnorm)) #TRUE.

#Sample-sample correlation. 
cor.raw_funnorm <- cor(betas.raw, betas.funnorm, use = "pairwise.complete.obs") #Input: Beta values to compare. 
plot(xaxt = "n", ylim = c(0.95, 1), xlab = "", ylab = "", diag(cor.raw_funnorm), main = "Sample-sample correlation", pch = 16, panel.first = grid()) +
axis(1, 1:44, labels = rownames(cor.raw_funnorm), las = 3, cex.axis = 0.8)

#Difference in beta values before and after normalisation.
diff = betas.funnorm - betas.raw
hist(diff, cex.axis = 0.8, breaks = 100, xlab = "", ylab = "", xlim = c(-0.8, 0.8), las = 1, main = "Difference in beta values before and after normalisation")
```


---------------------------------------------------------------------------------------------------------------------------


##Quality Control - Probe Filtering


###Step 1: Sex probes removal.

Probes that target the sex chromosomes are removed as both males and females have unequal amount X chromosomes - with females having twice the amount of X chromosomes as compared to males. So they need to be removed so that the analysis is not skewed on the basis of this disproportionate natural difference in chromosomal number. 

```{r}
load("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/AMD_gRSet.RData")

data(IlluminaHumanMethylation450kmanifest)
data(Locations)

#Check probe count before removal.
dim(AMD_gRSet.funnorm) #485512 probes.

#Get sex probes information from manifest file.
sex_probes <- Locations[which(Locations$chr == "chrY" | Locations$chr == "chrX"), ] %>% as.data.frame() 
dim(sex_probes) #19627 probes.

#Check the number of sex probes in the beta matrix.
AMD_sex_probes <- AMD_gRSet.funnorm[which(rownames(AMD_gRSet.funnorm) %in% rownames(sex_probes)),]
dim(AMD_sex_probes) #10583 probes.

#Remove sex probes from AMD beta matrix.
AMD_gRSet.funnorm <- AMD_gRSet.funnorm[!(rownames(AMD_gRSet.funnorm)%in%rownames(sex_probes)),]
dim(AMD_gRSet.funnorm) #474929 probes remaining after sex probes filtering. 
```


###Step 2: Cross-reactive and multi-mapped probes removal.

Non-specific and cross-hybridising probes are filtered according to the probes identified by [Chen et al.](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3592906/) and [Langmead & Salzberg](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3322381/). There are probes that target multiple sites in the human genome and/or pose potential hybridisation issues, and thus result in inaccurate methylation signals detection. 

**Cross-reactive probes** target highly repetitive sequences or co-hybridise to alternate sequences that are highly homologous to the intended targets, which could lead to the detection of spurious signals and potentially resulting in invalud conclusions and lack of validation in downstream analyses (Chen et al. 2013). Chen et al. (2013) proposes using the minimum number of bases matched to unintended targets of 47 bases for Infinium I and II probes to be used as criteria to identify cross-reactivity. They identified 8.4% of the Infinium I probes and 5.1% of the Infinium II probes (total: 6.0%) to be cross-reactive. 

```{r}
#Load Price annotation.
load("~/KoborLab/kobor_space/shared_coding_resource/Illumina_EPIC/fData_450_Price.RData")

#XY cross-hybridising probes.
XY_cross_hyb <- fData_450_Price[fData_450_Price$XY_Hits == "XY_YES",]$ILMNID
length(XY_cross_hyb) #12388 XY cross-hybridising probes.
AMD_gRSet.funnorm <- AMD_gRSet.funnorm[!(rownames(AMD_gRSet.funnorm) %in% XY_cross_hyb),] 
dim(AMD_gRSet.funnorm) #463426 probes after XY cross-hybridising probes removal.

#Autosomal cross-hybridising probes.
auto_cross_hyb <- fData_450_Price[fData_450_Price$Autosomal_Hits == "A_YES",]$ILMNID
length(auto_cross_hyb) #40650 autosomal cross-hybridising probes.
AMD_gRSet.funnorm <- AMD_gRSet.funnorm[!(rownames(AMD_gRSet.funnorm) %in% auto_cross_hyb),] 
dim(AMD_gRSet.funnorm) #434216 probes after autosomal cross-hybridising probes removal.
```


```{r, eval=FALSE}
#Load cross-hybridising and multi-mapped probes.
#cross.react <- read.csv("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/Non_specific_probes_450K.csv", header = TRUE, as.is = TRUE)
#cross.react.probes <- as.character(cross.react$TargetID)

#multi.map <- read.table("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/Cross_hybridising_probes_450K.txt", header = FALSE, as.is = TRUE)
#multi.map.probes <- as.character(multi.map$V1)

#Check for overlap between the two probe sets.
#filter.probes <- unique(c(cross.react.probes, multi.map.probes))
#length(filter.probes) #38941 probes.

#Remove cross-hybridising and multi-mapped probes. 
#table(rownames(betas.BMIQnoob) %in% filter.probes) #37760 cross-hybridising and multi-mapped probes in BMIQ-normalised beta matrix.
#betas.BMIQnoob <- betas.BMIQnoob[!(rownames(betas.BMIQnoob) %in% filter.probes),]
#dim(betas.BMIQnoob) #437169 probes remaining after cross-hybridising and multi-mapped probes are filtered.
```


###Step 3: Polymorphic probes removal.

**Polymorphic probes** are probes that target CpG sites that overlap known SNPs. The methylation levels detected for such CpGs can be greatly influenced by the underlying genetic polymorphism - thus they should be interpreted with caution (Chen et al. 2013). By cross-matching the genomic positions of both C and G of all array-targeted CpGs and the position of single base extension (Infinium I) to that of known SNPs in the 1,000 Genome database, we found 9.4% of the Infinium I probes and 15.5% of the Infinium II probes (total probes: 13.8%) to have methylation levels that **could** potentially be affected by genetic polymorphism. Caveat: Although it is shown that methylation profile from the Illumina HM450 microarray **could be greatly affected** by genetic polymorphism, the majority of the SNPs are rare with very low alternative allele frequencies, thus they would not be expected to have a major effect on methylation data when the population under study does not demonstrate a significant frequency of the rare allele. Studies that are focused on **intraindividual differences** rather than interindividual differences (such as tumour/normal tisssue differences; longitudinal evaluation of methylation profiles; monozygotic twin studies) are not expected to be confounded by such underlying SNPs. 

[Pidsley et al.](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-016-1066-1#Sec22) identify overlap with genetic variant categories with minor allele frequency > 5% at: (1) target CpG sites (n = 12,378); (2) single base extension sites of Type I probes (n = 772) using the EPIC array. 

```{r}
polymorphic_probes <- read.csv("~/KoborLab/kobor_space/kendrix/R_Functions/Pidsley_EPIC_polymorphic_probes.csv", header = TRUE)
polymorphic_probes <- as.character(polymorphic_probes$PROBE)
length(polymorphic_probes) #12510 polymorphic probes.

polymorphic_base_ext <- read.csv("~/KoborLab/kobor_space/kendrix/R_Functions/Pidsley_EPIC_single_base_ext_overlapping_SNP.csv", header = TRUE)
polymorphic_base_ext <- as.character(polymorphic_base_ext$PROBE)
length(polymorphic_base_ext) #414 probes that overlap with SNP at single base extension sites.

#Get overlap between two probe sets.
polymorphic_probes_to_filter <- unique(c(polymorphic_probes, polymorphic_base_ext))
length(polymorphic_probes_to_filter) #12679 probes to filter. 

#Remove polymorphic probes.
AMD_gRSet.funnorm <- AMD_gRSet.funnorm[!(rownames(AMD_gRSet.funnorm) %in% polymorphic_probes_to_filter),] 
dim(AMD_gRSet.funnorm) #427786 probes after polymorphic probes removal.
```


###Step 4: Bad detection p-value and low beadcount probes removal.

```{r, fig.align='center'}
load("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/AMD_detp_beadcount_QC.RData")
AMD_samplesheet <- read.csv("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/idats/AMD_project/AMD_samplesheet.csv", header = TRUE)

#Create a dummy matrix
bad_probes <- matrix(data = F, nrow = nrow(detp_minfi), ncol = ncol(detp_minfi),
                        dimnames = list(rownames(detp_minfi), colnames(detp_minfi))) %>% as.data.frame

#Designate TRUE to where beadcount < 3 and detection p-value > 0.01.
bad_probes[is.na(bead)] <- T
bad_probes[detp_minfi > 0.01] <- T

#Number of failed probes by samples.
AMD_samplesheet <- AMD_samplesheet %>% mutate(bad_probes = colSums(bad_probes))

#Check for samples that fail in more than 1% of total probes that have beadcount < 3 and detection p-value > 0.01.
AMD_samplesheet %>% 
  mutate(Sample_Name = factor(as.character(Sample_Name), levels = Sample_Name)) %>%
  ggplot(aes(x = Sample_Name, y = bad_probes)) +
  geom_point() +
  labs(x = 'Samples', y = '# probes with bead count < 3 or detection p > 0.01') +
  geom_hline(yintercept = 0.01*nrow(bad_probes), linetype = 'dashed', color = 'red') +
  geom_text(aes(x = 0, y = 0.01*nrow(bead)), label = '1%', vjust = -0.5, hjust = -0.5, color = 'red') +
  geom_label_repel(data = AMD_samplesheet %>% filter(bad_probes > 0.01*nrow(detp_minfi)),
                   aes(x = Sample_Name, y = bad_probes, label = Sample_Name),
                   force = 100, show.legend = F) +
  theme_classic() + theme(axis.text.x = element_blank()) 
```

```{r}
#Check for probes that are unsuccesfully measured in nth% of samples.
n_samples <- ncol(AMD_gRSet.funnorm)
bad_probes_count <- rowSums(bad_probes)

#Check thresholds to determine number of probes to remove:
#Probes that are unsuccessfully measured in 1% of samples.
sum(bad_probes_count > 0.010*n_samples) #18814 probes.

#Probes that are unsuccessfully measured in 2.5% of samples.
sum(bad_probes_count > 0.025*n_samples) #5050 probes.

#Probes that are unsuccesfully measured in 5% of samples.
sum(bad_probes_count > 0.050*n_samples) #3318 probes.

#Remove probes that are unsuccessfully measured in 5% of samples.
remove_probes <- data.frame(probe_ID = rownames(detp_minfi)) %>% mutate(bad_probes_count = bad_probes_count) %>% filter(bad_probes_count > 0.05*n_samples)
AMD_gRSet.funnorm.filt <- AMD_gRSet.funnorm[!(rownames(AMD_gRSet.funnorm) %in% remove_probes$probe_ID),]
dim(AMD_gRSet.funnorm.filt) #425456 probes remaining after detection p-value and beadcount probe filtering. 
```


###Step 5: Post probe filtering PCA. 

```{r}
#Load the probe filtered beta matrix.
betas.funnorm <- getBeta(AMD_gRSet.funnorm.filt)
meta <- pData(AMD_gRSet.funnorm.filt)

PCA_full <- princomp(betas.funnorm) #You can't have NAs in your dataframe - make sure to either remove probes with a lot of NAs and/or have imputed values. Can run na.omit but depending on the stage of pre-processing, could result in a lot of probes to be removed and a very inaccurate PCA.
Loadings <- as.data.frame(unclass(PCA_full$loadings))
vars <- PCA_full$sdev^2
Importance <- vars/sum(vars)
adjust <- 1-Importance[1]
pca_adjusted <- Importance[2:length(Importance)]/adjust
pca_df <- data.frame(adjusted_variance = pca_adjusted, PC = seq(1:length(pca_adjusted)))

#Restructure meta so that variables are in the appropriate format - categorical variables (sex is commonly labelled as 0 and 1) are factors and not numeric for example.

colnames(meta)[6] <- "Sentrix_Position"
colnames(meta)[7] <- "Sentrix_ID"

meta$Sentrix_ID <- as.factor(meta$Sentrix_ID)
meta$Sentrix_Position <- as.factor(meta$Sentrix_Position)
meta$Sex <- as.factor(meta$Sex)
meta$Sample_Group <- as.factor(meta$Sample_Group)
meta$Age <- as.numeric(meta$Age)

colnames(meta) #Obtain the column numbers to include.
meta_categorical <- data.frame(meta[, c(2,3,6,7)])  #Input column numbers in meta that contain categorical variables.
meta_continuous <- data.frame(meta[,4])  #Input column numbers in meta that contain continuous variables.
colnames(meta_categorical) #Write the line below to ensure you're changing the names of your variables in the right order.
colnames(meta_categorical) <- c("Disease state", "Sex", "Row", "Chip")
colnames(meta_continuous)
colnames(meta_continuous) <- c("Age")

Order <- c(seq(1:sum(ncol(meta_categorical), ncol(meta_continuous))))
Num <- 16 #This number will depend on your dataset - if you only have 6 samples, you should probably only show 5 PCs or less.
```

```{r, warning=FALSE, message=FALSE, fig.align='center', fig.height=7, fig.width=8}
#Run PCA.
source("~/KoborLab/kobor_space/kendrix/R_Functions/heat_scree_plot.R", local = knitr::knit_global())
heat_scree_plot(Loadings, Importance, Num, Order)
```


###Step 6: Save probe-filtered funnorm-normalised betas.

```{r}
save(AMD_gRSet.funnorm.filt, file = "~/KoborLab/kobor_space/kendrix/macular_degeneration/data/AMD_gRSet.funnorm.filt.RData")
```


---------------------------------------------------------------------------------------------------------------------------


##Cell Type Prediction


###Step 1: EpiDISH.

```{r, fig.align='center'}
library(EpiDISH)

#Load combat corrected data.
load("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/AMD_gRSet.funnorm.filt.RData")

AMD_pData <- as.data.frame(pData(AMD_gRSet.funnorm.filt))
betas.funnorm.filt <- getBeta(AMD_gRSet.funnorm.filt)

#Sanity checks.
sum(is.na(betas.funnorm.filt)) #0 NA.
sum(is.infinite(betas.funnorm.filt)) #0 inf. values.

#Load EpiDISH reference.
load("~/KoborLab/kobor_space/shared_coding_resource/EpiDish_Refs/centEpiFibIC.m.rda")
load("~/KoborLab/kobor_space/shared_coding_resource/EpiDish_Refs/centBloodSub.m.rda")

#Check to see if all the probes in the EpiDISH reference are in the combat corrected dataset.
all(rownames(centBloodSub.m) %in% rownames(betas.funnorm.filt)) #FALSE.
dim(centBloodSub.m[which(!rownames(centBloodSub.m) %in% rownames(betas.funnorm.filt)),]) #10 probes in the reference not in the combat corrected dataset.
all(rownames(centEpiFibIC.m) %in% rownames(betas.funnorm.filt)) #FALSE.
dim(centEpiFibIC.m[which(!rownames(centEpiFibIC.m) %in% rownames(betas.funnorm.filt)),]) #27 probes in the reference not in the combat corrected dataset.

AMD_Epi_counts <- as.data.frame(hepidish(betas.funnorm.filt, ref1.m = centEpiFibIC.m, ref2.m = centBloodSub.m, method = "RPC", h.CT.idx = 3))

#Plot EpiDISH cell type prediction. 
AMD_Epi.melt <- gather(AMD_Epi_counts)
colnames(AMD_Epi.melt)[1] <- "Cell_type"
colnames(AMD_Epi.melt)[2] <- "Estimated_proportions"

ggplot(AMD_Epi.melt, aes(factor(Cell_type), Estimated_proportions)) + 
  geom_boxplot(aes(fill = Cell_type), outlier.shape = NA) + 
  geom_jitter(aes(fill = Cell_type), size = 2, shape = 21, alpha = 0.7, 
              position = position_jitterdodge(dodge.width = 0.7, jitter.width = 0.1)) + 
  labs(x = "Cell Type", y = "Estimated Proportions",
       caption = "Estimated cell type proportion using EpiDISH") +
  scale_fill_manual(values = c("#7F44AB", "#56B4E9", "#E69F00", "#CC79A7", "#0072B2", "#009E73", "#D55E00", "#994C00", "#FFCCCC")) +
  theme_classic() + theme(plot.caption = element_text(hjust = 0.5, size = 12), legend.position = "none")
```


###Step 2: Cell type PCA.

```{r}
meta <- as.data.frame(AMD_pData)

#Check sample order to add cell type prediction to metadata.
identical(rownames(meta), rownames(AMD_Epi_counts)) #TRUE.

#Add cell type predictions to metadata.
meta <- cbind(meta, AMD_Epi_counts)

M_values.funnorm.filt <- beta2m(betas.funnorm.filt)
PCA_full <- princomp(M_values.funnorm.filt) #You can't have NAs in your dataframe - make sure to either remove probes with a lot of NAs and/or have imputed values. Can run na.omit but depending on the stage of pre-processing, could result in a lot of probes to be removed and a very inaccurate PCA.
Loadings <- as.data.frame(unclass(PCA_full$loadings))
vars <- PCA_full$sdev^2
Importance <- vars/sum(vars)
adjust <- 1-Importance[1]
pca_adjusted <- Importance[2:length(Importance)]/adjust
pca_df <- data.frame(adjusted_variance = pca_adjusted, PC = seq(1:length(pca_adjusted)))

#Restructure meta so that variables are in the appropriate format - categorical variables (sex is commonly labelled as 0 and 1) are factors and not numeric for example.

colnames(meta)[6] <- "Sentrix_Position"
colnames(meta)[7] <- "Sentrix_ID"

meta$Sentrix_ID <- as.factor(meta$Sentrix_ID)
meta$Sentrix_Position <- as.factor(meta$Sentrix_Position)
meta$Sex <- as.factor(meta$Sex)
meta$Sample_Group <- as.factor(meta$Sample_Group)
meta$Age <- as.numeric(meta$Age)
meta$Epi <- as.numeric(meta$Epi)
meta$Fib <- as.numeric(meta$Fib)
meta$B <- as.numeric(meta$B)
meta$NK <- as.numeric(meta$NK)
meta$CD4T <- as.numeric(meta$CD4T)
meta$CD8T <- as.numeric(meta$CD8T)
meta$Mono <- as.numeric(meta$Mono)
meta$Neutro <- as.numeric(meta$Neutro)
meta$Eosino <- as.numeric(meta$Eosino)


colnames(meta) #Obtain the column numbers to include.
meta_categorical <- data.frame(meta[, c(2,3,6,7)])  #Input column numbers in meta that contain categorical variables.
meta_continuous <- data.frame(meta[, c(4,13,14,15,16,17,19,20,21)])  #Input column numbers in meta that contain continuous variables.
colnames(meta_categorical) #Write the line below to ensure you're changing the names of your variables in the right order.
colnames(meta_categorical) <- c("Disease state", "Sex", "Row", "Chip")
colnames(meta_continuous)
colnames(meta_continuous) <- c("Age", "Epithelial", "Fibroblast", "B Cell", "NK Cell", "CD4T", "Monocyte", "Neutrophil", "Eosinophil")

Order <- c(seq(1:sum(ncol(meta_categorical), ncol(meta_continuous))))
Num <- 16 #This number will depend on your dataset - if you only have 6 samples, you should probably only show 5 PCs or less.
```

```{r, warning=FALSE, message=FALSE, fig.align='center', fig.height=7, fig.width=8}
#Run PCA.
source("~/KoborLab/kobor_space/kendrix/R_Functions/heat_scree_plot.R", local = knitr::knit_global())
heat_scree_plot(Loadings, Importance, Num, Order)
```


###Step 3: Save objects.

```{r}
save(AMD_Epi_counts, file = "~/KoborLab/kobor_space/kendrix/macular_degeneration/data/EpiDISH_celltype_prediction.RData")
```


---------------------------------------------------------------------------------------------------------------------------


##SVA

Surrogate variable analysis (SVA) (Jeffrey T Leek and John D Storey 2007, Jeffrey T Leek and John D Storey (2008)) is a useful tool to identified surrogate variables for unwanted variation while protecting for a phenotype of interest. In our experience, running SVA after normalizing the 450K data with preprocessFunnorm or preprocessQuantile increases the statistical power of the downstream analysis. For instance, to run SVA on the M-values, protecting for case-control status, the following code can be used to estimate the surrogate variables (this can take a few hours to run). 

Input: Instead of using ComBat-corrected data to determine SVs, use probe-filtered data instead because Disease State may be confounded with Row, so using ComBat will wipe out the Disease State effects. 


###Step 1: SVA v1 - All variables: Age + Disease State + Sex + Row + Chip.

NOTE: 1 significant SV. 

```{r}
#Load objects.
load("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/AMD_gRSet.funnorm.filt.RData")
AMD_pData <- as.data.frame(pData(AMD_gRSet.funnorm.filt))
M_values.funnorm.filt <- getM(AMD_gRSet.funnorm.filt)

#SVA with Disease State as fixed variable.
mod <- model.matrix(~ as.numeric(Age) + as.factor(Sample_Group) + as.factor(Sex) + as.factor(Slide) + as.factor(Array), data = AMD_pData) #Full model = variable of interest + adjustment variables (co-variates).
mod0 <- model.matrix(~as.factor(Sample_Group) + as.factor(Sex) + as.factor(Slide) + as.factor(Array), data = AMD_pData) #Null model = adjustment variables only. 
identical(rownames(mod), colnames(M_values.funnorm.filt)) #TRUE.
identical(rownames(mod0), colnames(M_values.funnorm.filt)) #TRUE.

#Check how many SVs.
n.sv <- num.sv(M_values.funnorm.filt, mod, method = "leek")
sva.results.all <- sva(M_values.funnorm.filt, mod, mod0, n.sv) 
#sva outputs four components: sv, pprob.gam, pprob.b, n.sv.
#sv = a matrix whose columns correspond to the estimated surrogate variables.
#pprob.gam = posterior probability that each CpG is associated with one or more latent variables. 
#pprob.b = posterior probability that each CpG is associated with the variables of interest. 
#n.sv = the number of surrogate variables estimated by the sva. 
```


###Step 2: SVA v2 - Confounding variables w.r.t Age: Age + Sex + Row + Chip.

NOTE: 1 significant SV. 

```{r}
#Load objects.
load("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/AMD_gRSet.funnorm.filt.RData")
AMD_pData <- as.data.frame(pData(AMD_gRSet.funnorm.filt))
M_values.funnorm.filt <- getM(AMD_gRSet.funnorm.filt)

#SVA with Disease State as fixed variable.
mod <- model.matrix(~ as.numeric(Age) + as.factor(Sex) + as.factor(Slide) + as.factor(Array), data = AMD_pData) #Full model = variable of interest + adjustment variables (co-variates).
mod0 <- model.matrix(~ as.factor(Sex) + as.factor(Slide) + as.factor(Array), data = AMD_pData) #Null model = adjustment variables only. 
identical(rownames(mod), colnames(M_values.funnorm.filt)) #TRUE.
identical(rownames(mod0), colnames(M_values.funnorm.filt)) #TRUE.

#Check how many SVs.
n.sv <- num.sv(M_values.funnorm.filt, mod, method = "leek")
sva.results.con <- sva(M_values.funnorm.filt, mod, mod0, n.sv) 
#sva outputs four components: sv, pprob.gam, pprob.b, n.sv.
#sv = a matrix whose columns correspond to the estimated surrogate variables.
#pprob.gam = posterior probability that each CpG is associated with one or more latent variables. 
#pprob.b = posterior probability that each CpG is associated with the variables of interest. 
#n.sv = the number of surrogate variables estimated by the sva. 
```


###Step 3: SVA v3 - Batch variables w.r.t Age: Age + Row + Chip.

NOTE: 1 significant SV. 

```{r}
#Load objects.
load("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/AMD_gRSet.funnorm.filt.RData")
AMD_pData <- as.data.frame(pData(AMD_gRSet.funnorm.filt))
M_values.funnorm.filt <- getM(AMD_gRSet.funnorm.filt)

#SVA with Disease State as fixed variable.
mod <- model.matrix(~ as.numeric(Age) + as.factor(Slide) + as.factor(Array), data = AMD_pData) #Full model = variable of interest + adjustment variables (co-variates).
mod0 <- model.matrix(~ as.factor(Slide) + as.factor(Array), data = AMD_pData) #Null model = adjustment variables only. 
identical(rownames(mod), colnames(M_values.funnorm.filt)) #TRUE.
identical(rownames(mod0), colnames(M_values.funnorm.filt)) #TRUE.

#Check how many SVs.
n.sv <- num.sv(M_values.funnorm.filt, mod, method = "leek")
sva.results.batch <- sva(M_values.funnorm.filt, mod, mod0, n.sv) 
#sva outputs four components: sv, pprob.gam, pprob.b, n.sv.
#sv = a matrix whose columns correspond to the estimated surrogate variables.
#pprob.gam = posterior probability that each CpG is associated with one or more latent variables. 
#pprob.b = posterior probability that each CpG is associated with the variables of interest. 
#n.sv = the number of surrogate variables estimated by the sva. 
```


###Step 4: SVA v4 - Only Age: Age.

NOTE: 1 significant SV. 

```{r}
#Load objects.
load("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/AMD_gRSet.funnorm.filt.RData")
AMD_pData <- as.data.frame(pData(AMD_gRSet.funnorm.filt))
M_values.funnorm.filt <- getM(AMD_gRSet.funnorm.filt)

#SVA with Disease State as fixed variable.
mod <- model.matrix(~ as.numeric(Age), data = AMD_pData) #Full model = variable of interest + adjustment variables (co-variates).
mod0 <- model.matrix(~ 1, data = AMD_pData) #Null model = adjustment variables only. 
identical(rownames(mod), colnames(M_values.funnorm.filt)) #TRUE.
identical(rownames(mod0), colnames(M_values.funnorm.filt)) #TRUE.

#Check how many SVs.
n.sv <- num.sv(M_values.funnorm.filt, mod, method = "leek")
sva.results.age <- sva(M_values.funnorm.filt, mod, mod0, n.sv) 
#sva outputs four components: sv, pprob.gam, pprob.b, n.sv.
#sv = a matrix whose columns correspond to the estimated surrogate variables.
#pprob.gam = posterior probability that each CpG is associated with one or more latent variables. 
#pprob.b = posterior probability that each CpG is associated with the variables of interest. 
#n.sv = the number of surrogate variables estimated by the sva. 
```


###Step 5: Check correlation between SVs. 

```{r}
SVs <- cbind(sva.results.all$sv, sva.results.con$sv)
SVs <- cbind(SVs, sva.results.batch$sv)
SVs <- cbind(SVs, sva.results.age$sv)
SVs <- as.data.frame(SVs)

colnames(SVs) <- c("SV_All", "SV_Confounders", "SV_Batch", "SV_Only_Age")
```

```{r, fig.align='center'}
#Check for correlation between the SVs.
ggplot(SVs, aes(SV_All, SV_Batch)) + geom_point() + theme_classic()
ggplot(SVs, aes(SV_All, SV_Confounders)) + geom_point() + theme_classic()
ggplot(SVs, aes(SV_Batch, SV_Confounders)) + geom_point() + theme_classic()
ggplot(SVs, aes(SV_Only_Age, SV_All)) + geom_point() + theme_classic()
ggplot(SVs, aes(SV_Only_Age, SV_Batch)) + geom_point() + theme_classic()
ggplot(SVs, aes(SV_Only_Age, SV_Confounders)) + geom_point() + theme_classic()
```


###Step 6: Add cell type prediction and SV to AMD_pData.

```{r}
load("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/EpiDISH_celltype_prediction.RData")

#Add SV and cell type prediction to AMD_pData.
identical(rownames(AMD_pData), rownames(AMD_Epi_counts))

AMD_pData <- cbind(AMD_pData, SVs$SV_All)
AMD_pData <- cbind(AMD_pData, AMD_Epi_counts)
colnames(AMD_pData)[13] <- "SV"
```


###Step 7: SV + Cell Type PCA.

Only SV PCA.

```{r}
meta <- as.data.frame(AMD_pData)
PCA_full <- princomp(M_values.funnorm.filt) #You can't have NAs in your dataframe - make sure to either remove probes with a lot of NAs and/or have imputed values. Can run na.omit but depending on the stage of pre-processing, could result in a lot of probes to be removed and a very inaccurate PCA.
Loadings <- as.data.frame(unclass(PCA_full$loadings))
vars <- PCA_full$sdev^2
Importance <- vars/sum(vars)
adjust <- 1-Importance[1]
pca_adjusted <- Importance[2:length(Importance)]/adjust
pca_df <- data.frame(adjusted_variance = pca_adjusted, PC = seq(1:length(pca_adjusted)))

#Restructure meta so that variables are in the appropriate format - categorical variables (sex is commonly labelled as 0 and 1) are factors and not numeric for example.

colnames(meta)[6] <- "Sentrix_Position"
colnames(meta)[7] <- "Sentrix_ID"

meta$Sentrix_ID <- as.factor(meta$Sentrix_ID)
meta$Sentrix_Position <- as.factor(meta$Sentrix_Position)
meta$Sex <- as.factor(meta$Sex)
meta$Sample_Group <- as.factor(meta$Sample_Group)
meta$Age <- as.numeric(meta$Age)
meta$SV <- as.numeric(meta$SV)

colnames(meta) #Obtain the column numbers to include.
meta_categorical <- data.frame(meta[, c(2,3,6,7)])  #Input column numbers in meta that contain categorical variables.
meta_continuous <- data.frame(meta[, c(4,13)])  #Input column numbers in meta that contain continuous variables.
colnames(meta_categorical) #Write the line below to ensure you're changing the names of your variables in the right order.
colnames(meta_categorical) <- c("Disease State", "Sex", "Row", "Chip")
colnames(meta_continuous)
colnames(meta_continuous) <- c("Age", "SV")

Order <- c(seq(1:sum(ncol(meta_categorical), ncol(meta_continuous))))
Num <- 16 #This number will depend on your dataset - if you only have 6 samples, you should probably only show 5 PCs or less.
```

```{r, warning=FALSE, message=FALSE, fig.align='center', fig.height=7, fig.width=8}
#Run PCA.
source("~/KoborLab/kobor_space/kendrix/R_Functions/heat_scree_plot.R", local = knitr::knit_global())
heat_scree_plot(Loadings, Importance, Num, Order)
```


SV + Cell Type PCA.

```{r}
meta <- as.data.frame(AMD_pData)
PCA_full <- princomp(M_values.funnorm.filt) #You can't have NAs in your dataframe - make sure to either remove probes with a lot of NAs and/or have imputed values. Can run na.omit but depending on the stage of pre-processing, could result in a lot of probes to be removed and a very inaccurate PCA.
Loadings <- as.data.frame(unclass(PCA_full$loadings))
vars <- PCA_full$sdev^2
Importance <- vars/sum(vars)
adjust <- 1-Importance[1]
pca_adjusted <- Importance[2:length(Importance)]/adjust
pca_df <- data.frame(adjusted_variance = pca_adjusted, PC = seq(1:length(pca_adjusted)))

#Restructure meta so that variables are in the appropriate format - categorical variables (sex is commonly labelled as 0 and 1) are factors and not numeric for example.

colnames(meta)[6] <- "Sentrix_Position"
colnames(meta)[7] <- "Sentrix_ID"

meta$Sentrix_ID <- as.factor(meta$Sentrix_ID)
meta$Sentrix_Position <- as.factor(meta$Sentrix_Position)
meta$Sex <- as.factor(meta$Sex)
meta$Sample_Group <- as.factor(meta$Sample_Group)
meta$Age <- as.numeric(meta$Age)
meta$SV <- as.numeric(meta$SV)
meta$Epi <- as.numeric(meta$Epi)
meta$Fib <- as.numeric(meta$Fib)
meta$B <- as.numeric(meta$B)
meta$NK <- as.numeric(meta$NK)
meta$CD4T <- as.numeric(meta$CD4T)
meta$CD8T <- as.numeric(meta$CD8T)
meta$Mono <- as.numeric(meta$Mono)
meta$Neutro <- as.numeric(meta$Neutro)
meta$Eosino <- as.numeric(meta$Eosino)

colnames(meta) #Obtain the column numbers to include.
meta_categorical <- data.frame(meta[, c(2,3,6,7)])  #Input column numbers in meta that contain categorical variables.
meta_continuous <- data.frame(meta[, c(4,13:18,20:22)])  #Input column numbers in meta that contain continuous variables.
colnames(meta_categorical) #Write the line below to ensure you're changing the names of your variables in the right order.
colnames(meta_categorical) <- c("Disease State", "Sex", "Row", "Chip")
colnames(meta_continuous)
colnames(meta_continuous) <- c("Age", "SV", "Epithelial", "Fibroblast", "B Cell", "NK Cell", "CD4T", "Monocyte", "Neutrophil", "Eosinophil")

Order <- c(seq(1:sum(ncol(meta_categorical), ncol(meta_continuous))))
Num <- 16 #This number will depend on your dataset - if you only have 6 samples, you should probably only show 5 PCs or less.
```

```{r, warning=FALSE, message=FALSE, fig.align='center', fig.height=7, fig.width=8}
#Run PCA.
source("~/KoborLab/kobor_space/kendrix/R_Functions/heat_scree_plot.R", local = knitr::knit_global())
heat_scree_plot(Loadings, Importance, Num, Order)
```


###Step 8: Clean-up final pData object and save objects.

```{r}
#Clean up column names of AMD_pData.
colnames(AMD_pData)[2] <- "Disease_State"
colnames(AMD_pData)[6:7] <- c("Row", "Chip")
colnames(AMD_pData)[14:22] <- c("Epithelial", "Fibroblast", "B_Cell", "NK_Cell", "CD4T", "CD8T", "Monocyte", "Neutrophil", "Eosinophil")

save(AMD_pData, M_values.funnorm.filt, file = "~/KoborLab/kobor_space/kendrix/macular_degeneration/data/AMD_SVA_M_values.funnorm.RData")
```


---------------------------------------------------------------------------------------------------------------------------


##Correlation between variables


###Step 1: Look at metadata heatmap.

Look for correlation between variables in the metadata. There might be a possibility that Age and Sex are confounded with Batch.

```{r}
#Load objects.
load("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/AMD_SVA_M_values.funnorm.RData")

#Subset the biological and technical variables to check correlation.
colnames(AMD_pData) #Check columns to subset.
meta.cor <- AMD_pData[, c(2:4, 6:7, 13:18, 20:22)] #I didn't include tissue because they are all the same tissue. 

#Turn categorical variables into numerical variables.
meta.cor$Disease_State <- as.numeric(unlist(as.factor(meta.cor$Disease_State)))
meta.cor$Sex <- as.numeric((unlist(as.factor(meta.cor$Sex))))
meta.cor$Age <- as.numeric(meta.cor$Age)
meta.cor$Row <- as.numeric(unlist(as.factor(meta.cor$Row)))
meta.cor$Chip <- as.numeric(unlist(as.factor(meta.cor$Chip)))

str(meta.cor)
```

```{r, fig.align='center'}
#Metadata correlation.
colnames(meta.cor) #Choose variables to check.
meta.SV.celltype <- meta.cor[, c(6:14)]

grey <- colorRampPalette(brewer.pal(n = 9, "BrBG"))
heatmap.2(cor(meta.SV.celltype, use = "pairwise.complete.obs", method = "spearman"), cexCol = 1.5, cexRow = 1.5, col = grey, dendrogram = "both", scale = "none", margins = c(8,8), trace = "none", keysize = 1.3)
```

```{r, fig.align='center'}
#Metadata correlation.
colnames(meta.cor) #Choose variables to check.
meta.all <- meta.cor[, c(1:7)]

grey <- colorRampPalette(brewer.pal(n = 9, "BrBG"))
heatmap.2(cor(meta.all, use = "pairwise.complete.obs", method = "spearman"), cexCol = 1.5, cexRow = 1.5, col = grey, dendrogram = "both", scale = "none", margins = c(10,10), trace = "none", keysize = 1.3)
```


###Step 2: Look at final PCA.

```{r}
meta <- as.data.frame(AMD_pData)
PCA_full <- princomp(M_values.funnorm.filt) #You can't have NAs in your dataframe - make sure to either remove probes with a lot of NAs and/or have imputed values. Can run na.omit but depending on the stage of pre-processing, could result in a lot of probes to be removed and a very inaccurate PCA.
Loadings <- as.data.frame(unclass(PCA_full$loadings))
vars <- PCA_full$sdev^2
Importance <- vars/sum(vars)
adjust <- 1-Importance[1]
pca_adjusted <- Importance[2:length(Importance)]/adjust
pca_df <- data.frame(adjusted_variance = pca_adjusted, PC = seq(1:length(pca_adjusted)))

#Restructure meta so that variables are in the appropriate format - categorical variables (sex is commonly labelled as 0 and 1) are factors and not numeric for example.

colnames(meta)[6] <- "Sentrix_Position"
colnames(meta)[7] <- "Sentrix_ID"

meta$Sentrix_ID <- as.factor(meta$Sentrix_ID)
meta$Sentrix_Position <- as.factor(meta$Sentrix_Position)
meta$Sex <- as.factor(meta$Sex)
meta$Disease_State <- as.factor(meta$Disease_State)
meta$Age <- as.numeric(meta$Age)
meta$SV <- as.numeric(meta$SV)
meta$Epithelial <- as.numeric(meta$Epithelial)

colnames(meta) #Obtain the column numbers to include.
meta_categorical <- data.frame(meta[, c(2,3,6,7)])  #Input column numbers in meta that contain categorical variables.
meta_continuous <- data.frame(meta[, c(4,13,14)])  #Input column numbers in meta that contain continuous variables.
colnames(meta_categorical) #Write the line below to ensure you're changing the names of your variables in the right order.
colnames(meta_categorical) <- c("Disease State", "Sex", "Row", "Chip")
colnames(meta_continuous)

Order <- c(seq(1:sum(ncol(meta_categorical), ncol(meta_continuous))))
Num <- 16 #This number will depend on your dataset - if you only have 6 samples, you should probably only show 5 PCs or less.
```

```{r, warning=FALSE, message=FALSE, fig.align='center', fig.height=7, fig.width=8}
#Run PCA.
source("~/KoborLab/kobor_space/kendrix/R_Functions/heat_scree_plot.R", local = knitr::knit_global())
heat_scree_plot(Loadings, Importance, Num, Order)
```


###Step 3: Plot Age that is confounded by Chip effect.

```{r, fig.align='center'}
#Age is confounded by chip. 
ggplot(AMD_pData, aes(Chip, Age)) + 
  geom_boxplot() + 
  geom_jitter(aes(fill = Chip), position = position_jitterdodge(dodge.width = 0.75, jitter.width = 0.3)) + 
  xlab("Chip") + 
  scale_x_discrete(breaks = c("200723300084","200723300089","200723300090","200770460039"), labels = c("Chip084","Chip089","Chip090","Chip039")) + 
  theme_classic2() + theme(legend.position = "none")
```


---------------------------------------------------------------------------------------------------------------------------


##EWAS Replication

###Replicating Porter et al.'s hits using their model. 

The chunks below are done in an attempt to replicate [Porter et al.'s](https://clinicalepigeneticsjournal.biomedcentral.com/articles/10.1186/s13148-019-0608-2#Sec16) hits in their publication to check the integrity of the dataset.

```{r}
#Load all the objects.
load("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/AMD_SVA_M_values.funnorm.RData") 

dim(AMD_pData) #44 samples.
dim(M_values.funnorm.filt) #425456 probes.

AMD_pData$Disease_State <- as.factor(AMD_pData$Disease_State)
AMD_pData$Sex <- as.factor(AMD_pData$Sex)
AMD_pData$Row <- as.factor(AMD_pData$Row)
AMD_pData$Chip <- as.factor(AMD_pData$Chip)
AMD_pData$Age <- as.numeric(AMD_pData$Age)

str(AMD_pData)

#Check order.
identical(rownames(AMD_pData), colnames(M_values.funnorm.filt)) #TRUE. 

#Sanity check - there should be no NAs or infinite numbers - which could be a result of logit transformation of 0 or 1 beta values. 
all(complete.cases(M_values.funnorm.filt)) == "TRUE" #TRUE - meaning no NA or infinite numbers. 
```

```{r, eval=FALSE}
library(pbapply) #Progress bar for apply functions.

#EWAS on Disease_State - All samples.
#LM: Need to use transformed M-values instead of beta values as it is more statistically sound.
Porter_LM_pval <- pbsapply(1:nrow(M_values.funnorm.filt), function(CpG){
  meta <- AMD_pData
  meta$Mval <- M_values.funnorm.filt[CpG,]
  mod_Porter <- lm(Mval ~ Disease_State + Sex + Disease_State*Sex + Chip, data = meta) 
  coef(summary(mod_Porter))[2,4]}) #Returns nominal p-value for Disease State for model at each CpG.
head(Porter_LM_pval)

save(Porter_LM_pval, file = "~/KoborLab/kobor_space/kendrix/macular_degeneration/data/Porter_LM_pval.RData")
```

```{r, fig.align='center'}
load("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/Porter_LM_pval.RData")

#Inspect p-value distribution for model.
pvalue_dist_Porter <- data.frame(CpG = rownames(M_values.funnorm.filt), Nominal_P = Porter_LM_pval)
ggplot(pvalue_dist_Porter, aes(Nominal_P)) + 
  geom_histogram(fill = "grey90", color = "black") + 
  theme_classic() + xlab("Nominal P Value") + 
  ylim(0, 20000) + 
  xlim(min(Porter_LM_pval), max(Porter_LM_pval))
#Not right-skewed. Distribution is a little even. 

#Multiple test correction with FDR.
M_values.funnorm.filt <- as.data.frame(M_values.funnorm.filt)
Multi_test_corr_relaxed <- p.adjust(Porter_LM_pval, method = "fdr", n = length(Porter_LM_pval))

#Looking at FDR thresholds for hits:
dim(as.data.frame(M_values.funnorm.filt)[which(Multi_test_corr_relaxed <= 0.05),]) #0 at 0.05.
dim(as.data.frame(M_values.funnorm.filt)[which(Multi_test_corr_relaxed <= 0.1),]) #0 at 0.1.
dim(as.data.frame(M_values.funnorm.filt)[which(Multi_test_corr_relaxed <= 0.2),]) #1 at 0.2.

#Looking at top hits by nominal P:
pvalue_dist_Porter <- pvalue_dist_Porter[order(pvalue_dist_Porter$Nominal_P),]
head(pvalue_dist_Porter)

#Load 450K annotation data.
load("~/KoborLab/kobor_space/shared_coding_resource/Illumina_EPIC/EPIC_Annotation_Complete.RData")
head(EPIC_Annotation_Complete)

dim(hits_CpGs <- pvalue_dist_Porter[which(pvalue_dist_Porter$Nominal_P < 1e-6),]) #2 hits.
hits <- EPIC_Annotation_Complete[which(EPIC_Annotation_Complete$Name%in%hits_CpGs$CpG),]
hits$UCSC_RefGene_Name
```

```{r, eval=FALSE}
#Delta beta.
#Using Maggie's code for deltabeta:
deltabeta <- function(df, mainvar, covar1 = NULL, covar2 = NULL, covar3 = NULL, covar4 = NULL, covar5 = NULL) {
  # Calculating delta beta of the main variable of interest (mainvar), with up to 5 possible covariates (covar)
  # mainvar should be a vector of continuous variable
  # all covars should also be vectors
  # df = dataframe or matrix of beta values
  # output is a vector of delta beta values
  sd=sd(mainvar)
  qt <-
    range <- max(mainvar, na.rm = T) - min(mainvar, na.rm = T)
  dB <- vector(mode = "numeric", length = nrow(df))
  names(dB) <- rownames(df)
  for (i in 1:nrow(df)) {
    beta <- df[i, ]
    if (is.null(covar1)) {
      mod <- lm(beta ~ mainvar)
    } else if (is.null(covar2)) {
      mod <- lm(beta ~ mainvar + covar1)
    } else if (is.null(covar3)) {
      mod <- lm(beta ~ mainvar + covar1 + covar2)
    } else if (is.null(covar4)) {
      mod <- lm(beta ~ mainvar + covar1 + covar2 + covar3)
    } else if (is.null(covar5)) {
      mod <- lm(beta ~ mainvar + covar1 + covar2 + covar3 + covar4)
    } else {
      mod <- lm(beta ~ mainvar + covar1 + covar2 + covar3 + covar4 + covar5)
    }
    slope <- mod$coefficients[2]
    dB[i] <- as.numeric(slope*range)
  }
  dB
}

betas.funnorm.filt <- m2beta(M_values.funnorm.filt)

delta_beta_Porter_fixed <- deltabeta(as.matrix(betas.funnorm.filt), as.numeric(as.factor(AMD_pData$Disease_State)), 
                                     covar1 = as.numeric(as.factor(AMD_pData$Sex)), 
                                     covar2 = as.numeric(as.factor(AMD_pData$Disease_State))*as.numeric(as.factor(AMD_pData$Sex)),
                                     covar3 = as.numeric(as.factor(AMD_pData$Chip)))
length(delta_beta_Porter_fixed)
summary(delta_beta_Porter_fixed)

save(delta_beta_Porter_fixed, file = "~/KoborLab/kobor_space/kendrix/macular_degeneration/data/DB_Porter_fixed.RData")
```

```{r, fig.align='center'}
##3. Linear Model: Volcano Plot
#Volcano to examine hits (for DB, see below chunks):
load("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/DB_Porter_fixed.RData")

#Call Volcano (Nominal p Version, modified from Rachel's code):
source("/home/BCRICWH.LAN/dlin/KoborLab/kobor_space/cake/home/dlin/Volcano_DL_Nominal.R")

#After running the last 2 chunks, make a summary table with CpG, Nominal_P, FDR, and Delta Beta.
Porter_Table <- data.frame(rownames(M_values.funnorm.filt), Porter_LM_pval, Multi_test_corr_relaxed, delta_beta_Porter_fixed)
colnames(Porter_Table) = c("CpG", "Nominal_P", "FDR", "Delta_Beta")
identical(as.character(rownames(Porter_Table)), as.character(Porter_Table$CpG)) #TRUE.

#Looking at top hits quickly without considering DB:
head(Porter_Table[order(Porter_Table$Nominal_P),],10)

##Setting a threshold of 0.05DB, 5e-6 Nominal P (scale to 0.60DB):
makeVolcano_nominal(Porter_Table$Nominal_P, Porter_Table$Delta_Beta, 0.05, 1e-6, "DNAm changes", 0.3) #at 5e-6: 7 Hypermethylated, 0 Hypomethylated

#What are these hits?
#First make an annotated table - load 450K manifest.
load("~/KoborLab/kobor_space/shared_coding_resource/Illumina_EPIC/EPIC_Annotation_Complete.RData")
head(EPIC_Annotation_Complete)

Porter_Table.annotated = merge(Porter_Table, EPIC_Annotation_Complete[,c("Name", "CHR", "Strand", "UCSC_RefGene_Name", "UCSC_RefGene_Group")], by.x = "CpG", by.y = "Name", all = FALSE)
colnames(Porter_Table.annotated)[5:6] = c("Chromosome", "Coordinate")
Porter_Table.annotated <- Porter_Table.annotated[order(Porter_Table.annotated$Nominal_P),]

#Grabbing the Volcano hits:
LM_Porter_Hits <- Porter_Table.annotated[which(abs(Porter_Table.annotated$Delta_Beta)>0.05 & Porter_Table.annotated$Nominal_P<1e-6),]

#Let's order by Nominal_P:
LM_Porter_Hits = LM_Porter_Hits[order(LM_Porter_Hits$Nominal_P),]
rownames(LM_Porter_Hits) = c()
str(LM_Porter_Hits)
head(LM_Porter_Hits)
```


---------------------------------------------------------------------------------------------------------------------------


##EWAS


###EWAS Model 1: All Samples on Age only.

No covariates.

```{r}
#Load all the objects.
load("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/AMD_SVA_M_values.funnorm.RData") 

dim(AMD_pData) #44 samples.
dim(M_values.funnorm.filt) #425456 probes.

AMD_pData$Disease_State <- as.factor(AMD_pData$Disease_State)
AMD_pData$Sex <- as.factor(AMD_pData$Sex)
AMD_pData$Row <- as.factor(AMD_pData$Row)
AMD_pData$Chip <- as.factor(AMD_pData$Chip)
AMD_pData$Age <- as.numeric(AMD_pData$Age)

str(AMD_pData)

#Check order.
identical(rownames(AMD_pData), colnames(M_values.funnorm.filt)) #TRUE. 

#Sanity check - there should be no NAs or infinite numbers - which could be a result of logit transformation of 0 or 1 beta values. 
all(complete.cases(M_values.funnorm.filt)) == "TRUE" #TRUE - meaning no NA or infinite numbers. 
```

```{r, eval=FALSE}
library(pbapply) #Progress bar for apply functions.

#EWAS on Age - All samples.
#LM: Need to use transformed M-values instead of beta values as it is more statistically sound.
Age_LM_pval <- pbsapply(1:nrow(M_values.funnorm.filt), function(CpG){
  meta <- AMD_pData
  meta$Mval <- M_values.funnorm.filt[CpG,]
  mod_Age <- lm(Mval ~ Age, data = meta) 
  coef(summary(mod_Age))[2,4]}) #Returns nominal p-value for Age for model at each CpG.
head(Age_LM_pval)

save(Age_LM_pval, file = "~/KoborLab/kobor_space/kendrix/macular_degeneration/data/Age_LM_pval.RData")
```

```{r, fig.align='center'}
load("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/Age_LM_pval.RData")

#Inspect p-value distribution for model.
pvalue_dist_Age <- data.frame(CpG = rownames(M_values.funnorm.filt), Nominal_P = Age_LM_pval)
ggplot(pvalue_dist_Age, aes(Nominal_P)) + 
  geom_histogram(fill = "grey90", color = "black") + 
  theme_classic() + xlab("Nominal P Value") + 
  ylim(0, 20000) + 
  xlim(min(Age_LM_pval), max(Age_LM_pval))
#Not right-skewed. Distribution is a little even. 

#Multiple test correction with FDR.
M_values.funnorm.filt <- as.data.frame(M_values.funnorm.filt)
Multi_test_corr_relaxed <- p.adjust(Age_LM_pval, method = "fdr", n = length(Age_LM_pval))

#Looking at FDR thresholds for hits:
dim(as.data.frame(M_values.funnorm.filt)[which(Multi_test_corr_relaxed <= 0.05),]) #1 at 0.05.
dim(as.data.frame(M_values.funnorm.filt)[which(Multi_test_corr_relaxed <= 0.1),]) #1 at 0.1.
dim(as.data.frame(M_values.funnorm.filt)[which(Multi_test_corr_relaxed <= 0.2),]) #8 at 0.2.

#Looking at top hits by nominal P:
pvalue_dist_Age <- pvalue_dist_Age[order(pvalue_dist_Age$Nominal_P),]
head(pvalue_dist_Age)

#Load 450K annotation data.
load("~/KoborLab/kobor_space/shared_coding_resource/Illumina_EPIC/EPIC_Annotation_Complete.RData")
head(EPIC_Annotation_Complete)

dim(hits_CpGs <- pvalue_dist_Age[which(pvalue_dist_Age$Nominal_P < 1e-6),]) #2 hits.
hits <- EPIC_Annotation_Complete[which(EPIC_Annotation_Complete$Name%in%hits_CpGs$CpG),]
hits$UCSC_RefGene_Name
```

```{r, eval=FALSE}
#Delta beta.
#Using Maggie's code for deltabeta:
deltabeta <- function(df, mainvar, covar1 = NULL, covar2 = NULL, covar3 = NULL, covar4 = NULL, covar5 = NULL) {
  # Calculating delta beta of the main variable of interest (mainvar), with up to 5 possible covariates (covar)
  # mainvar should be a vector of continuous variable
  # all covars should also be vectors
  # df = dataframe or matrix of beta values
  # output is a vector of delta beta values
  sd=sd(mainvar)
  qt <-
    range <- max(mainvar, na.rm = T) - min(mainvar, na.rm = T)
  dB <- vector(mode = "numeric", length = nrow(df))
  names(dB) <- rownames(df)
  for (i in 1:nrow(df)) {
    beta <- df[i, ]
    if (is.null(covar1)) {
      mod <- lm(beta ~ mainvar)
    } else if (is.null(covar2)) {
      mod <- lm(beta ~ mainvar + covar1)
    } else if (is.null(covar3)) {
      mod <- lm(beta ~ mainvar + covar1 + covar2)
    } else if (is.null(covar4)) {
      mod <- lm(beta ~ mainvar + covar1 + covar2 + covar3)
    } else if (is.null(covar5)) {
      mod <- lm(beta ~ mainvar + covar1 + covar2 + covar3 + covar4)
    } else {
      mod <- lm(beta ~ mainvar + covar1 + covar2 + covar3 + covar4 + covar5)
    }
    slope <- mod$coefficients[2]
    dB[i] <- as.numeric(slope*range)
  }
  dB
}

betas.funnorm.filt <- m2beta(M_values.funnorm.filt)

delta_beta_Age_fixed <- deltabeta(as.matrix(betas.funnorm.filt), AMD_pData$Age)
length(delta_beta_Age_fixed)
summary(delta_beta_Age_fixed)

save(delta_beta_Age_fixed, file = "~/KoborLab/kobor_space/kendrix/macular_degeneration/data/DB_Age_fixed.RData")
```

```{r, fig.align='center'}
##3. Linear Model: Volcano Plot
#Volcano to examine hits (for DB, see below chunks):
load("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/DB_Age_fixed.RData")

#Call Volcano (Nominal p Version, modified from Rachel's code):
source("/home/BCRICWH.LAN/dlin/KoborLab/kobor_space/cake/home/dlin/Volcano_DL_Nominal.R")

#After running the last 2 chunks, make a summary table with CpG, Nominal_P, FDR, and Delta Beta.
Age_Table <- data.frame(rownames(M_values.funnorm.filt), Age_LM_pval, Multi_test_corr_relaxed, delta_beta_Age_fixed)
colnames(Age_Table) = c("CpG", "Nominal_P", "FDR", "Delta_Beta")
identical(as.character(rownames(Age_Table)), as.character(Age_Table$CpG)) #TRUE.

#Looking at top hits quickly without considering DB:
head(Age_Table[order(Age_Table$Nominal_P),],10)

##Setting a threshold of 0.05DB, 5e-6 Nominal P (scale to 0.60DB):
makeVolcano_nominal(Age_Table$Nominal_P, Age_Table$Delta_Beta, 0.05, 5e-6, "DNAm changes", 0.3) #at 5e-6: 7 Hypermethylated, 0 Hypomethylated

#What are these hits?
#First make an annotated table - load 450K manifest.
load("~/KoborLab/kobor_space/shared_coding_resource/Illumina_EPIC/EPIC_Annotation_Complete.RData")
head(EPIC_Annotation_Complete)

Age_Table.annotated = merge(Age_Table, EPIC_Annotation_Complete[,c("Name", "CHR", "Strand", "UCSC_RefGene_Name", "UCSC_RefGene_Group")], by.x = "CpG", by.y = "Name", all = FALSE)
colnames(Age_Table.annotated)[5:6] = c("Chromosome", "Coordinate")
Age_Table.annotated <- Age_Table.annotated[order(Age_Table.annotated$Nominal_P),]

#Grabbing the Volcano hits:
LM_Age_Hits <- Age_Table.annotated[which(abs(Age_Table.annotated$Delta_Beta)>0.05 & Age_Table.annotated$Nominal_P<5e-6),]

#Let's order by Nominal_P:
LM_Age_Hits = LM_Age_Hits[order(LM_Age_Hits$Nominal_P),]
rownames(LM_Age_Hits) = c()
str(LM_Age_Hits)
head(LM_Age_Hits)
```

Age-associated hits: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3482848/
Non-tissue specific hits: https://epigeneticsandchromatin.biomedcentral.com/articles/10.1186/s13072-018-0191-3

```{r}
#Reorder row index.
rownames(Age_Table.annotated) <- NULL

#Look at hits based on candidate genes.
head(Age_Table.annotated[which(Age_Table.annotated$UCSC_RefGene_Name == "ELOVL2"),]) #First ELOVL2 hit == row 14999.
head(Age_Table.annotated[which(Age_Table.annotated$UCSC_RefGene_Name == "EDARADD"),]) #First EDARADD hit == row 198718.
head(Age_Table.annotated[which(Age_Table.annotated$UCSC_RefGene_Name == "TOM1L1"),]) #First TOM1L1 hit == row 6147.
head(Age_Table.annotated[which(Age_Table.annotated$UCSC_RefGene_Name == "NPTX2"),]) #First NPTX2 hit == row 18625.
```


###EWAS Model 2: All samples on Age + SV.

Only SV (cell type) as covariate.

```{r}
#Load all the objects.
load("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/AMD_SVA_M_values.funnorm.RData") 

dim(AMD_pData) #44 samples.
dim(M_values.funnorm.filt) #425456 probes.

AMD_pData$Disease_State <- as.factor(AMD_pData$Disease_State)
AMD_pData$Sex <- as.factor(AMD_pData$Sex)
AMD_pData$Row <- as.factor(AMD_pData$Row)
AMD_pData$Chip <- as.factor(AMD_pData$Chip)
AMD_pData$Age <- as.numeric(AMD_pData$Age)

str(AMD_pData)

#Check order.
identical(rownames(AMD_pData), colnames(M_values.funnorm.filt)) #TRUE. 

#Sanity check - there should be no NAs or infinite numbers - which could be a result of logit transformation of 0 or 1 beta values. 
all(complete.cases(M_values.funnorm.filt)) == "TRUE" #TRUE - meaning no NA or infinite numbers. 
```

```{r, eval=FALSE}
library(pbapply) #Progress bar for apply functions.

#EWAS on Age - All samples + SV.
#LM: Need to use transformed M-values instead of beta values as it is more statistically sound.
Age.SV_LM_pval <- pbsapply(1:nrow(M_values.funnorm.filt), function(CpG){
  meta <- AMD_pData
  meta$Mval <- M_values.funnorm.filt[CpG,]
  mod_Age.SV <- lm(Mval ~ Age + SV, data = meta) #Only SV as covariate.
  coef(summary(mod_Age.SV))[2,4]}) #Returns nominal p-value for Age for model at each CpG.
head(Age.SV_LM_pval)

save(Age.SV_LM_pval, file = "~/KoborLab/kobor_space/kendrix/macular_degeneration/data/Age.SV_LM_pval.RData")
```

```{r, fig.align='center'}
load("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/Age.SV_LM_pval.RData")

#Inspect p-value distribution for model.
pvalue_dist_Age.SV <- data.frame(CpG = rownames(M_values.funnorm.filt), Nominal_P = Age.SV_LM_pval)
ggplot(pvalue_dist_Age.SV, aes(Nominal_P)) + 
  geom_histogram(fill = "grey90", color = "black") + 
  theme_classic() + xlab("Nominal P Value") + 
  ylim(0, 20000) + 
  xlim(min(Age.SV_LM_pval), max(Age.SV_LM_pval))
#Not right-skewed. Distribution is a little even. 

#Multiple test correction with FDR.
M_values.funnorm.filt <- as.data.frame(M_values.funnorm.filt)
Multi_test_corr_relaxed <- p.adjust(Age.SV_LM_pval, method = "fdr", n = length(Age.SV_LM_pval))

#Looking at FDR thresholds for hits:
dim(as.data.frame(M_values.funnorm.filt)[which(Multi_test_corr_relaxed <= 0.05),]) #5 at 0.05.
dim(as.data.frame(M_values.funnorm.filt)[which(Multi_test_corr_relaxed <= 0.1),]) #18 at 0.1.
dim(as.data.frame(M_values.funnorm.filt)[which(Multi_test_corr_relaxed <= 0.2),]) #133 at 0.2.

#Looking at top hits by nominal P:
pvalue_dist_Age.SV <- pvalue_dist_Age.SV[order(pvalue_dist_Age.SV$Nominal_P),]
head(pvalue_dist_Age.SV)

#Load 450K annotation data.
load("~/KoborLab/kobor_space/shared_coding_resource/Illumina_EPIC/EPIC_Annotation_Complete.RData")
head(EPIC_Annotation_Complete)

dim(hits_CpGs <- pvalue_dist_Age.SV[which(pvalue_dist_Age.SV$Nominal_P < 1e-6),]) #5 hits.
hits <- EPIC_Annotation_Complete[which(EPIC_Annotation_Complete$Name%in%hits_CpGs$CpG),]
hits$UCSC_RefGene_Name
```

```{r, eval=FALSE}
#Delta beta.
#Using Maggie's code for deltabeta:
deltabeta <- function(df, mainvar, covar1 = NULL, covar2 = NULL, covar3 = NULL, covar4 = NULL, covar5 = NULL) {
  # Calculating delta beta of the main variable of interest (mainvar), with up to 5 possible covariates (covar)
  # mainvar should be a vector of continuous variable
  # all covars should also be vectors
  # df = dataframe or matrix of beta values
  # output is a vector of delta beta values
  sd=sd(mainvar)
  qt <-
    range <- max(mainvar, na.rm = T) - min(mainvar, na.rm = T)
  dB <- vector(mode = "numeric", length = nrow(df))
  names(dB) <- rownames(df)
  for (i in 1:nrow(df)) {
    beta <- df[i, ]
    if (is.null(covar1)) {
      mod <- lm(beta ~ mainvar)
    } else if (is.null(covar2)) {
      mod <- lm(beta ~ mainvar + covar1)
    } else if (is.null(covar3)) {
      mod <- lm(beta ~ mainvar + covar1 + covar2)
    } else if (is.null(covar4)) {
      mod <- lm(beta ~ mainvar + covar1 + covar2 + covar3)
    } else if (is.null(covar5)) {
      mod <- lm(beta ~ mainvar + covar1 + covar2 + covar3 + covar4)
    } else {
      mod <- lm(beta ~ mainvar + covar1 + covar2 + covar3 + covar4 + covar5)
    }
    slope <- mod$coefficients[2]
    dB[i] <- as.numeric(slope*range)
  }
  dB
}

betas.funnorm.filt <- m2beta(M_values.funnorm.filt)

delta_beta_Age.SV_fixed <- deltabeta(as.matrix(betas.funnorm.filt), AMD_pData$Age, covar1 = AMD_pData$SV)
length(delta_beta_Age.SV_fixed)
summary(delta_beta_Age.SV_fixed)

save(delta_beta_Age.SV_fixed, file = "~/KoborLab/kobor_space/kendrix/macular_degeneration/data/DB_Age.SV_fixed.RData")
```

```{r, fig.align='center'}
##3. Linear Model: Volcano Plot
#Volcano to examine hits (for DB, see below chunks):
load("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/DB_Age.SV_fixed.RData")

#Call Volcano (Nominal p Version, modified from Rachel's code):
source("/home/BCRICWH.LAN/dlin/KoborLab/kobor_space/cake/home/dlin/Volcano_DL_Nominal.R")

#After running the last 2 chunks, make a summary table with CpG, Nominal_P, FDR, and Delta Beta.
Age.SV_Table <- data.frame(rownames(M_values.funnorm.filt), Age.SV_LM_pval, Multi_test_corr_relaxed, delta_beta_Age.SV_fixed)
colnames(Age.SV_Table) = c("CpG", "Nominal_P", "FDR", "Delta_Beta")
identical(as.character(rownames(Age.SV_Table)), as.character(Age.SV_Table$CpG)) #TRUE.

#Looking at top hits quickly without considering DB:
head(Age.SV_Table[order(Age.SV_Table$Nominal_P),],10)

##Setting a threshold of 0.05DB, 5e-6 Nominal P (scale to 0.60DB):
makeVolcano_nominal(Age.SV_Table$Nominal_P, Age.SV_Table$Delta_Beta, 0.05, 5e-6, "DNAm changes", 0.3) #at 5e-6: 17 Hypermethylated, 1 Hypomethylated

#What are these hits?
#First make an annotated table - load 450K manifest.
load("/home/BCRICWH.LAN/ngladish/KoborLab/kobor_space/shared_coding_resource/Illumina_EPIC/EPIC_Annotation_Complete.RData")
colnames(EPIC_Annotation_Complete)

Age.SV_Table.annotated = merge(Age.SV_Table, EPIC_Annotation_Complete[,c("Name", "CHR", "Strand", "UCSC_RefGene_Name", "UCSC_RefGene_Group")], by.x = "CpG", by.y = "Name", all = FALSE)
colnames(Age.SV_Table.annotated)[5:6] = c("Chromosome", "Coordinate")
Age.SV_Table.annotated <- Age.SV_Table.annotated[order(Age.SV_Table.annotated$Nominal_P),]

#Grabbing the Volcano hits:
LM_Age.SV_Hits <- Age.SV_Table.annotated[which(abs(Age.SV_Table.annotated$Delta_Beta)>0.05 & Age.SV_Table.annotated$Nominal_P<5e-6),]

#Let's order by Nominal_P:
LM_Age.SV_Hits = LM_Age.SV_Hits[order(LM_Age.SV_Hits$Nominal_P),]
rownames(LM_Age.SV_Hits) = c()
str(LM_Age.SV_Hits)
head(LM_Age.SV_Hits)
```

Age-associated hits: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3482848/
Non-tissue specific hits: https://epigeneticsandchromatin.biomedcentral.com/articles/10.1186/s13072-018-0191-3

```{r}
#Reorder row index.
rownames(Age.SV_Table.annotated) <- NULL

#Look at hits based on candidate genes.
head(Age.SV_Table.annotated[which(Age.SV_Table.annotated$UCSC_RefGene_Name == "ELOVL2"),]) #First ELOVL2 hit == row 78.
head(Age.SV_Table.annotated[which(Age.SV_Table.annotated$UCSC_RefGene_Name == "EDARADD"),]) #First EDARADD hit == row 92628.
head(Age.SV_Table.annotated[which(Age.SV_Table.annotated$UCSC_RefGene_Name == "TOM1L1"),]) #First TOM1L1 hit == row 836.
head(Age.SV_Table.annotated[which(Age.SV_Table.annotated$UCSC_RefGene_Name == "NPTX2"),]) #First NPTX2 hit == row 3231.
```


###EWAS Model 3: All samples on Age + SV + Chip.

SV (cell type) and chip as covariates.

```{r}
#Load all the objects.
load("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/AMD_SVA_M_values.funnorm.RData") 

dim(AMD_pData) #44 samples.
dim(M_values.funnorm.filt) #425456 probes.

AMD_pData$Disease_State <- as.factor(AMD_pData$Disease_State)
AMD_pData$Sex <- as.factor(AMD_pData$Sex)
AMD_pData$Row <- as.factor(AMD_pData$Row)
AMD_pData$Chip <- as.factor(AMD_pData$Chip)
AMD_pData$Age <- as.numeric(AMD_pData$Age)

str(AMD_pData)

#Check order.
identical(rownames(AMD_pData), colnames(M_values.funnorm.filt)) #TRUE. 

#Sanity check - there should be no NAs or infinite numbers - which could be a result of logit transformation of 0 or 1 beta values. 
all(complete.cases(M_values.funnorm.filt)) == "TRUE" #TRUE - meaning no NA or infinite numbers. 
```

```{r, eval=FALSE}
library(pbapply) #Progress bar for apply functions.

#EWAS on Age - All samples + SV + Chip.
#LM: Need to use transformed M-values instead of beta values as it is more statistically sound.
Age.SV.chip_LM_pval <- pbsapply(1:nrow(M_values.funnorm.filt), function(CpG){
  meta <- AMD_pData
  meta$Mval <- M_values.funnorm.filt[CpG,]
  mod_Age.SV.chip <- lm(Mval ~ Age + SV + Chip, data = meta) #Only SV + Chip as covariate.
  coef(summary(mod_Age.SV.chip))[2,4]}) #Returns nominal p-value for Age for model at each CpG.
head(Age.SV.chip_LM_pval)

save(Age.SV.chip_LM_pval, file = "~/KoborLab/kobor_space/kendrix/macular_degeneration/data/Age.SV.chip_LM_pval.RData")
```

```{r, fig.align='center'}
load("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/Age.SV.chip_LM_pval.RData")

#Inspect p-value distribution for model.
pvalue_dist_Age.SV.chip <- data.frame(CpG = rownames(M_values.funnorm.filt), Nominal_P = Age.SV.chip_LM_pval)
ggplot(pvalue_dist_Age.SV.chip, aes(Nominal_P)) + 
  geom_histogram(fill = "grey90", color = "black") + 
  theme_classic() + xlab("Nominal P Value") + 
  ylim(0, 20000) + 
  xlim(min(Age.SV.chip_LM_pval), max(Age.SV.chip_LM_pval))
#Right-skewed. 

#Multiple test correction with FDR.
M_values.funnorm.filt <- as.data.frame(M_values.funnorm.filt)
Multi_test_corr_relaxed <- p.adjust(Age.SV.chip_LM_pval, method = "fdr", n = length(Age.SV.chip_LM_pval))

#Looking at FDR thresholds for hits:
dim(as.data.frame(M_values.funnorm.filt)[which(Multi_test_corr_relaxed <= 0.05),]) #0 at 0.05.
dim(as.data.frame(M_values.funnorm.filt)[which(Multi_test_corr_relaxed <= 0.1),]) #1 at 0.1.
dim(as.data.frame(M_values.funnorm.filt)[which(Multi_test_corr_relaxed <= 0.2),]) #12 at 0.2.

#Looking at top hits by nominal P:
pvalue_dist_Age.SV.chip <- pvalue_dist_Age.SV.chip[order(pvalue_dist_Age.SV.chip$Nominal_P),]
head(pvalue_dist_Age.SV.chip)

#Load 450K annotation data.
load("~/KoborLab/kobor_space/shared_coding_resource/Illumina_EPIC/EPIC_Annotation_Complete.RData")
head(EPIC_Annotation_Complete)

dim(hits_CpGs <- pvalue_dist_Age.SV.chip[which(pvalue_dist_Age.SV.chip$Nominal_P < 1e-6),]) #2 hits.
hits <- EPIC_Annotation_Complete[which(EPIC_Annotation_Complete$Name%in%hits_CpGs$CpG),]
hits$UCSC_RefGene_Name
```

```{r, eval=FALSE}
#Delta beta.
#Using Maggie's code for deltabeta:
deltabeta <- function(df, mainvar, covar1 = NULL, covar2 = NULL, covar3 = NULL, covar4 = NULL, covar5 = NULL) {
  # Calculating delta beta of the main variable of interest (mainvar), with up to 5 possible covariates (covar)
  # mainvar should be a vector of continuous variable
  # all covars should also be vectors
  # df = dataframe or matrix of beta values
  # output is a vector of delta beta values
  sd=sd(mainvar)
  qt <-
    range <- max(mainvar, na.rm = T) - min(mainvar, na.rm = T)
  dB <- vector(mode = "numeric", length = nrow(df))
  names(dB) <- rownames(df)
  for (i in 1:nrow(df)) {
    beta <- df[i, ]
    if (is.null(covar1)) {
      mod <- lm(beta ~ mainvar)
    } else if (is.null(covar2)) {
      mod <- lm(beta ~ mainvar + covar1)
    } else if (is.null(covar3)) {
      mod <- lm(beta ~ mainvar + covar1 + covar2)
    } else if (is.null(covar4)) {
      mod <- lm(beta ~ mainvar + covar1 + covar2 + covar3)
    } else if (is.null(covar5)) {
      mod <- lm(beta ~ mainvar + covar1 + covar2 + covar3 + covar4)
    } else {
      mod <- lm(beta ~ mainvar + covar1 + covar2 + covar3 + covar4 + covar5)
    }
    slope <- mod$coefficients[2]
    dB[i] <- as.numeric(slope*range)
  }
  dB
}

betas.funnorm.filt <- m2beta(M_values.funnorm.filt)

delta_beta_Age.SV.chip_fixed <- deltabeta(as.matrix(betas.funnorm.filt), AMD_pData$Age, covar1 = AMD_pData$SV, covar2 = AMD_pData$Chip)
length(delta_beta_Age.SV.chip_fixed)
summary(delta_beta_Age.SV.chip_fixed)

save(delta_beta_Age.SV.chip_fixed, file = "~/KoborLab/kobor_space/kendrix/macular_degeneration/data/DB_Age.SV.chip_fixed.RData")
```

```{r, fig.align='center'}
##3. Linear Model: Volcano Plot
#Volcano to examine hits (for DB, see below chunks):
load("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/DB_Age.SV.chip_fixed.RData")

#Call Volcano (Nominal p Version, modified from Rachel's code):
source("/home/BCRICWH.LAN/dlin/KoborLab/kobor_space/cake/home/dlin/Volcano_DL_Nominal.R")

#After running the last 2 chunks, make a summary table with CpG, Nominal_P, FDR, and Delta Beta.
Age.SV.chip_Table <- data.frame(rownames(M_values.funnorm.filt), Age.SV.chip_LM_pval, Multi_test_corr_relaxed, delta_beta_Age.SV.chip_fixed)
colnames(Age.SV.chip_Table) = c("CpG", "Nominal_P", "FDR", "Delta_Beta")
identical(as.character(rownames(Age.SV.chip_Table)), as.character(Age.SV.chip_Table$CpG)) #TRUE.

#Looking at top hits quickly without considering DB:
head(Age.SV.chip_Table[order(Age.SV.chip_Table$Nominal_P),],10)

##Setting a threshold of 0.05DB, 5e-6 Nominal P (scale to 0.60DB):
makeVolcano_nominal(Age.SV.chip_Table$Nominal_P, Age.SV.chip_Table$Delta_Beta, 0.05, 1e-6, "DNAm changes", 0.3) #at 5e-6: 9 Hypermethylated, 0 Hypomethylated

#What are these hits?
#First make an annotated table - load 450K manifest.
load("~/KoborLab/kobor_space/shared_coding_resource/Illumina_EPIC/EPIC_Annotation_Complete.RData")
head(EPIC_Annotation_Complete)

Age.SV.chip_Table.annotated = merge(Age.SV.chip_Table, EPIC_Annotation_Complete[,c("Name", "CHR", "Strand", "UCSC_RefGene_Name", "UCSC_RefGene_Group")], by.x = "CpG", by.y = "Name", all = FALSE)
colnames(Age.SV.chip_Table.annotated)[5:6] = c("Chromosome", "Coordinate")
Age.SV.chip_Table.annotated <- Age.SV.chip_Table.annotated[order(Age.SV.chip_Table.annotated$Nominal_P),]

#Grabbing the Volcano hits:
LM_Age.SV.chip_Hits <- Age.SV.chip_Table.annotated[which(abs(Age.SV.chip_Table.annotated$Delta_Beta)>0.05 & Age.SV.chip_Table.annotated$Nominal_P<1e-6),]

#Let's order by Nominal_P:
LM_Age.SV.chip_Hits = LM_Age.SV.chip_Hits[order(LM_Age.SV.chip_Hits$Nominal_P),]
rownames(LM_Age.SV.chip_Hits) = c()
str(LM_Age.SV.chip_Hits)
head(LM_Age.SV.chip_Hits)
```

Age-associated hits: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3482848/
Non-tissue specific hits: https://epigeneticsandchromatin.biomedcentral.com/articles/10.1186/s13072-018-0191-3

```{r}
#Reorder row index.
rownames(Age.SV.chip_Table.annotated) <- NULL

#Look at hits based on candidate genes.
head(Age.SV.chip_Table.annotated[which(Age.SV.chip_Table.annotated$CpG %in% c("cg16867657", "cg21572722", "cg24724428")),]) #Identified ELOVL2 sites.
head(Age.SV.chip_Table.annotated[which(Age.SV.chip_Table.annotated$CpG %in% c("cg06639320", "cg22454769", "cg24079702")),]) #Identified FHL2 sites.
head(Age.SV.chip_Table.annotated[which(Age.SV.chip_Table.annotated$UCSC_RefGene_Name == "DIP2C"),]) #First TOM1L1 hit == row 3937.
head(Age.SV.chip_Table.annotated[which(Age.SV.chip_Table.annotated$UCSC_RefGene_Name == "NPTX2"),]) #First NPTX2 hit == row 6776.
head(Age.SV.chip_Table.annotated[which(Age.SV.chip_Table.annotated$UCSC_RefGene_Name == "PENK"),]) #First NPTX2 hit == row 6776.
```


###EWAS Model 4: All samples on Age + Sex + SV.

Sex and SV (cell type) as covariates.

```{r}
#Load all the objects.
load("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/AMD_SVA_M_values.funnorm.RData") 

dim(AMD_pData) #44 samples.
dim(M_values.funnorm.filt) #425456 probes.

AMD_pData$Disease_State <- as.factor(AMD_pData$Disease_State)
AMD_pData$Sex <- as.factor(AMD_pData$Sex)
AMD_pData$Row <- as.factor(AMD_pData$Row)
AMD_pData$Chip <- as.factor(AMD_pData$Chip)
AMD_pData$Age <- as.numeric(AMD_pData$Age)

str(AMD_pData)

#Check order.
identical(rownames(AMD_pData), colnames(M_values.funnorm.filt)) #TRUE. 

#Sanity check - there should be no NAs or infinite numbers - which could be a result of logit transformation of 0 or 1 beta values. 
all(complete.cases(M_values.funnorm.filt)) == "TRUE" #TRUE - meaning no NA or infinite numbers. 
```

```{r, eval=FALSE}
library(pbapply) #Progress bar for apply functions.

#EWAS on Age - All samples + Sex + SV.
#LM: Need to use transformed M-values instead of beta values as it is more statistically sound.
Age.Sex.SV_LM_pval <- pbsapply(1:nrow(M_values.funnorm.filt), function(CpG){
  meta <- AMD_pData
  meta$Mval <- M_values.funnorm.filt[CpG,]
  mod_Age.Sex.SV <- lm(Mval ~ Age + Sex + SV, data = meta) #Only Sex + SV as covariate.
  coef(summary(mod_Age.Sex.SV))[2,4]}) #Returns nominal p-value for Age for model at each CpG.
head(Age.Sex.SV_LM_pval)

save(Age.Sex.SV_LM_pval, file = "~/KoborLab/kobor_space/kendrix/macular_degeneration/data/Age.Sex.SV_LM_pval.RData")
```

```{r, fig.align='center'}
load("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/Age.Sex.SV_LM_pval.RData")

#Inspect p-value distribution for model.
pvalue_dist_Age.Sex.SV <- data.frame(CpG = rownames(M_values.funnorm.filt), Nominal_P = Age.Sex.SV_LM_pval)
ggplot(pvalue_dist_Age.Sex.SV, aes(Nominal_P)) + 
  geom_histogram(fill = "grey90", color = "black") + 
  theme_classic() + xlab("Nominal P Value") + 
  ylim(0, 20000) + 
  xlim(min(Age.Sex.SV_LM_pval), max(Age.Sex.SV_LM_pval))
#Not right-skewed. Distribution is a little even. 

#Multiple test correction with FDR.
M_values.funnorm.filt <- as.data.frame(M_values.funnorm.filt)
Multi_test_corr_relaxed <- p.adjust(Age.Sex.SV_LM_pval, method = "fdr", n = length(Age.Sex.SV_LM_pval))

#Looking at FDR thresholds for hits:
dim(as.data.frame(M_values.funnorm.filt)[which(Multi_test_corr_relaxed <= 0.05),]) #20 at 0.05.
dim(as.data.frame(M_values.funnorm.filt)[which(Multi_test_corr_relaxed <= 0.1),]) #49 at 0.1.
dim(as.data.frame(M_values.funnorm.filt)[which(Multi_test_corr_relaxed <= 0.2),]) #143 at 0.2.

#Looking at top hits by nominal P:
pvalue_dist_Age.Sex.SV <- pvalue_dist_Age.Sex.SV[order(pvalue_dist_Age.Sex.SV$Nominal_P),]
head(pvalue_dist_Age.Sex.SV)

#Load 450K annotation data.
load("~/KoborLab/kobor_space/shared_coding_resource/Illumina_EPIC/EPIC_Annotation_Complete.RData")
head(EPIC_Annotation_Complete)

dim(hits_CpGs <- pvalue_dist_Age.Sex.SV[which(pvalue_dist_Age.Sex.SV$Nominal_P < 1e-6),]) #8 hits.
hits <- EPIC_Annotation_Complete[which(EPIC_Annotation_Complete$Name%in%hits_CpGs$CpG),]
hits$UCSC_RefGene_Name
```

```{r, eval=FALSE}
#Delta beta.
#Using Maggie's code for deltabeta:
deltabeta <- function(df, mainvar, covar1 = NULL, covar2 = NULL, covar3 = NULL, covar4 = NULL, covar5 = NULL) {
  # Calculating delta beta of the main variable of interest (mainvar), with up to 5 possible covariates (covar)
  # mainvar should be a vector of continuous variable
  # all covars should also be vectors
  # df = dataframe or matrix of beta values
  # output is a vector of delta beta values
  sd=sd(mainvar)
  qt <-
    range <- max(mainvar, na.rm = T) - min(mainvar, na.rm = T)
  dB <- vector(mode = "numeric", length = nrow(df))
  names(dB) <- rownames(df)
  for (i in 1:nrow(df)) {
    beta <- df[i, ]
    if (is.null(covar1)) {
      mod <- lm(beta ~ mainvar)
    } else if (is.null(covar2)) {
      mod <- lm(beta ~ mainvar + covar1)
    } else if (is.null(covar3)) {
      mod <- lm(beta ~ mainvar + covar1 + covar2)
    } else if (is.null(covar4)) {
      mod <- lm(beta ~ mainvar + covar1 + covar2 + covar3)
    } else if (is.null(covar5)) {
      mod <- lm(beta ~ mainvar + covar1 + covar2 + covar3 + covar4)
    } else {
      mod <- lm(beta ~ mainvar + covar1 + covar2 + covar3 + covar4 + covar5)
    }
    slope <- mod$coefficients[2]
    dB[i] <- as.numeric(slope*range)
  }
  dB
}

betas.funnorm.filt <- m2beta(M_values.funnorm.filt)

delta_beta_Age.Sex.SV_fixed <- deltabeta(as.matrix(betas.funnorm.filt), AMD_pData$Age, covar1 = AMD_pData$Sex, covar2 = AMD_pData$SV)
length(delta_beta_Age.Sex.SV_fixed)
summary(delta_beta_Age.Sex.SV_fixed)

save(delta_beta_Age.Sex.SV_fixed, file = "~/KoborLab/kobor_space/kendrix/macular_degeneration/data/DB_Age.Sex.SV_fixed.RData")
```

```{r, fig.align='center'}
##3. Linear Model: Volcano Plot
#Volcano to examine hits (for DB, see below chunks):
load("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/DB_Age.Sex.SV_fixed.RData")

#Call Volcano (Nominal p Version, modified from Rachel's code):
source("/home/BCRICWH.LAN/dlin/KoborLab/kobor_space/cake/home/dlin/Volcano_DL_Nominal.R")

#After running the last 2 chunks, make a summary table with CpG, Nominal_P, FDR, and Delta Beta.
Age.Sex.SV_Table <- data.frame(rownames(M_values.funnorm.filt), Age.Sex.SV_LM_pval, Multi_test_corr_relaxed, delta_beta_Age.Sex.SV_fixed)
colnames(Age.Sex.SV_Table) = c("CpG", "Nominal_P", "FDR", "Delta_Beta")
identical(as.character(rownames(Age.Sex.SV_Table)), as.character(Age.Sex.SV_Table$CpG)) #TRUE.

#Looking at top hits quickly without considering DB:
head(Age.Sex.SV_Table[order(Age.Sex.SV_Table$Nominal_P),],10)

##Setting a threshold of 0.05DB, 5e-6 Nominal P (scale to 0.60DB):
makeVolcano_nominal(Age.Sex.SV_Table$Nominal_P, Age.Sex.SV_Table$Delta_Beta, 0.05, 5e-6, "DNAm changes", 0.5) #at 5e-6: 9 Hypermethylated, 0 Hypomethylated

#What are these hits?
#First make an annotated table - load 450K manifest.
load("~/KoborLab/kobor_space/shared_coding_resource/Illumina_EPIC/EPIC_Annotation_Complete.RData")
head(EPIC_Annotation_Complete)

Age.Sex.SV_Table.annotated = merge(Age.Sex.SV_Table, EPIC_Annotation_Complete[,c("Name", "CHR", "Strand", "UCSC_RefGene_Name", "UCSC_RefGene_Group")], by.x = "CpG", by.y = "Name", all = FALSE)
colnames(Age.Sex.SV_Table.annotated)[5:6] = c("Chromosome", "Coordinate")
Age.Sex.SV_Table.annotated <- Age.Sex.SV_Table.annotated[order(Age.Sex.SV_Table.annotated$Nominal_P),]

#Grabbing the Volcano hits:
LM_Age.Sex.SV_Hits <- Age.Sex.SV_Table.annotated[which(abs(Age.Sex.SV_Table.annotated$Delta_Beta)>0.05 & Age.Sex.SV_Table.annotated$Nominal_P<5e-6),]

#Let's order by Nominal_P:
LM_Age.Sex.SV_Hits = LM_Age.Sex.SV_Hits[order(LM_Age.Sex.SV_Hits$Nominal_P),]
rownames(LM_Age.Sex.SV_Hits) = c()
str(LM_Age.Sex.SV_Hits)
head(LM_Age.Sex.SV_Hits)
```

Age-associated hits: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3482848/
Non-tissue specific hits: https://epigeneticsandchromatin.biomedcentral.com/articles/10.1186/s13072-018-0191-3

```{r}
#Reorder row index.
rownames(Age.Sex.SV_Table.annotated) <- NULL

#Look at hits based on candidate genes.
head(Age.Sex.SV_Table.annotated[which(Age.Sex.SV_Table.annotated$UCSC_RefGene_Name == "ELOVL2"),]) #First ELOVL2 hit == row 278.
head(Age.Sex.SV_Table.annotated[which(Age.Sex.SV_Table.annotated$UCSC_RefGene_Name == "EDARADD"),]) #First EDARADD hit == row 111292.
head(Age.Sex.SV_Table.annotated[which(Age.Sex.SV_Table.annotated$UCSC_RefGene_Name == "TOM1L1"),]) #First TOM1L1 hit == row 2140.
head(Age.Sex.SV_Table.annotated[which(Age.Sex.SV_Table.annotated$UCSC_RefGene_Name == "NPTX2"),]) #First NPTX2 hit == row 8828.
```


###EWAS Model 5: All samples on Age + Sex + SV + Chip.

Sex, SV (cell type) and chip as covariates.

```{r}
#Load all the objects.
load("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/AMD_SVA_M_values.funnorm.RData") 

dim(AMD_pData) #44 samples.
dim(M_values.funnorm.filt) #425456 probes.

AMD_pData$Disease_State <- as.factor(AMD_pData$Disease_State)
AMD_pData$Sex <- as.factor(AMD_pData$Sex)
AMD_pData$Row <- as.factor(AMD_pData$Row)
AMD_pData$Chip <- as.factor(AMD_pData$Chip)
AMD_pData$Age <- as.numeric(AMD_pData$Age)

str(AMD_pData)

#Check order.
identical(rownames(AMD_pData), colnames(M_values.funnorm.filt)) #TRUE. 

#Sanity check - there should be no NAs or infinite numbers - which could be a result of logit transformation of 0 or 1 beta values. 
all(complete.cases(M_values.funnorm.filt)) == "TRUE" #TRUE - meaning no NA or infinite numbers. 
```

```{r, eval=FALSE}
library(pbapply) #Progress bar for apply functions.

#EWAS on Age - All samples + Sex + SV + Chip.
#LM: Need to use transformed M-values instead of beta values as it is more statistically sound.
Age.Sex.SV.chip_LM_pval <- pbsapply(1:nrow(M_values.funnorm.filt), function(CpG){
  meta <- AMD_pData
  meta$Mval <- M_values.funnorm.filt[CpG,]
  mod_Age.Sex.SV.chip <- lm(Mval ~ Age + Sex + SV + Chip, data = meta) #Only Sex + SV + Chip as covariate.
  coef(summary(mod_Age.Sex.SV.chip))[2,4]}) #Returns nominal p-value for Age for model at each CpG.
head(Age.Sex.SV.chip_LM_pval)

save(Age.Sex.SV.chip_LM_pval, file = "~/KoborLab/kobor_space/kendrix/macular_degeneration/data/Age.Sex.SV.chip_LM_pval.RData")
```

```{r, fig.align='center'}
load("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/Age.Sex.SV.chip_LM_pval.RData")

#Inspect p-value distribution for model.
pvalue_dist_Age.Sex.SV.chip <- data.frame(CpG = rownames(M_values.funnorm.filt), Nominal_P = Age.Sex.SV.chip_LM_pval)
ggplot(pvalue_dist_Age.Sex.SV.chip, aes(Nominal_P)) + 
  geom_histogram(fill = "grey90", color = "black") + 
  theme_classic() + xlab("Nominal P Value") + 
  ylim(0, 20000) + 
  xlim(min(Age.Sex.SV.chip_LM_pval), max(Age.Sex.SV.chip_LM_pval))
#Not right-skewed. Distribution is a little even. 

#Multiple test correction with FDR.
M_values.funnorm.filt <- as.data.frame(M_values.funnorm.filt)
Multi_test_corr_relaxed <- p.adjust(Age.Sex.SV.chip_LM_pval, method = "fdr", n = length(Age.Sex.SV.chip_LM_pval))

#Looking at FDR thresholds for hits:
dim(as.data.frame(M_values.funnorm.filt)[which(Multi_test_corr_relaxed <= 0.05),]) #20 at 0.05.
dim(as.data.frame(M_values.funnorm.filt)[which(Multi_test_corr_relaxed <= 0.1),]) #49 at 0.1.
dim(as.data.frame(M_values.funnorm.filt)[which(Multi_test_corr_relaxed <= 0.2),]) #143 at 0.2.

#Looking at top hits by nominal P:
pvalue_dist_Age.Sex.SV.chip <- pvalue_dist_Age.Sex.SV.chip[order(pvalue_dist_Age.Sex.SV.chip$Nominal_P),]
head(pvalue_dist_Age.Sex.SV.chip)

#Load 450K annotation data.
load("~/KoborLab/kobor_space/shared_coding_resource/Illumina_EPIC/EPIC_Annotation_Complete.RData")
head(EPIC_Annotation_Complete)

dim(hits_CpGs <- pvalue_dist_Age.Sex.SV.chip[which(pvalue_dist_Age.Sex.SV.chip$Nominal_P < 1e-6),]) #8 hits.
hits <- EPIC_Annotation_Complete[which(EPIC_Annotation_Complete$Name%in%hits_CpGs$CpG),]
hits$UCSC_RefGene_Name
```

```{r, eval=FALSE}
#Delta beta.
#Using Maggie's code for deltabeta:
deltabeta <- function(df, mainvar, covar1 = NULL, covar2 = NULL, covar3 = NULL, covar4 = NULL, covar5 = NULL) {
  # Calculating delta beta of the main variable of interest (mainvar), with up to 5 possible covariates (covar)
  # mainvar should be a vector of continuous variable
  # all covars should also be vectors
  # df = dataframe or matrix of beta values
  # output is a vector of delta beta values
  sd=sd(mainvar)
  qt <-
    range <- max(mainvar, na.rm = T) - min(mainvar, na.rm = T)
  dB <- vector(mode = "numeric", length = nrow(df))
  names(dB) <- rownames(df)
  for (i in 1:nrow(df)) {
    beta <- df[i, ]
    if (is.null(covar1)) {
      mod <- lm(beta ~ mainvar)
    } else if (is.null(covar2)) {
      mod <- lm(beta ~ mainvar + covar1)
    } else if (is.null(covar3)) {
      mod <- lm(beta ~ mainvar + covar1 + covar2)
    } else if (is.null(covar4)) {
      mod <- lm(beta ~ mainvar + covar1 + covar2 + covar3)
    } else if (is.null(covar5)) {
      mod <- lm(beta ~ mainvar + covar1 + covar2 + covar3 + covar4)
    } else {
      mod <- lm(beta ~ mainvar + covar1 + covar2 + covar3 + covar4 + covar5)
    }
    slope <- mod$coefficients[2]
    dB[i] <- as.numeric(slope*range)
  }
  dB
}

betas.funnorm.filt <- m2beta(M_values.funnorm.filt)

delta_beta_Age.Sex.SV.chip_fixed <- deltabeta(as.matrix(betas.funnorm.filt), AMD_pData$Age, covar1 = AMD_pData$Sex, covar2 = AMD_pData$SV, covar3 = AMD_pData$Chip)
length(delta_beta_Age.Sex.SV.chip_fixed)
summary(delta_beta_Age.Sex.SV.chip_fixed)

save(delta_beta_Age.Sex.SV.chip_fixed, file = "~/KoborLab/kobor_space/kendrix/macular_degeneration/data/DB_Age.Sex.SV.chip_fixed.RData")
```

```{r, fig.align='center'}
##3. Linear Model: Volcano Plot
#Volcano to examine hits (for DB, see below chunks):
load("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/DB_Age.Sex.SV.chip_fixed.RData")

#Call Volcano (Nominal p Version, modified from Rachel's code):
source("/home/BCRICWH.LAN/dlin/KoborLab/kobor_space/cake/home/dlin/Volcano_DL_Nominal.R")

#After running the last 2 chunks, make a summary table with CpG, Nominal_P, FDR, and Delta Beta.
Age.Sex.SV.chip_Table <- data.frame(rownames(M_values.funnorm.filt), Age.Sex.SV.chip_LM_pval, Multi_test_corr_relaxed, delta_beta_Age.Sex.SV.chip_fixed)
colnames(Age.Sex.SV.chip_Table) = c("CpG", "Nominal_P", "FDR", "Delta_Beta")
identical(as.character(rownames(Age.Sex.SV.chip_Table)), as.character(Age.Sex.SV.chip_Table$CpG)) #TRUE.

#Looking at top hits quickly without considering DB:
head(Age.Sex.SV.chip_Table[order(Age.Sex.SV.chip_Table$Nominal_P),],10)

##Setting a threshold of 0.05DB, 5e-6 Nominal P (scale to 0.60DB):
makeVolcano_nominal(Age.Sex.SV.chip_Table$Nominal_P, Age.Sex.SV.chip_Table$Delta_Beta, 0.05, 3e-6, "DNAm changes", 0.5) #at 5e-6: 9 Hypermethylated, 0 Hypomethylated

#What are these hits?
#First make an annotated table - load 450K manifest.
load("~/KoborLab/kobor_space/shared_coding_resource/Illumina_EPIC/EPIC_Annotation_Complete.RData")
head(EPIC_Annotation_Complete)

Age.Sex.SV.chip_Table.annotated = merge(Age.Sex.SV.chip_Table, EPIC_Annotation_Complete[,c("Name", "CHR", "Strand", "UCSC_RefGene_Name", "UCSC_RefGene_Group")], by.x = "CpG", by.y = "Name", all = FALSE)
colnames(Age.Sex.SV.chip_Table.annotated)[5:6] = c("Chromosome", "Coordinate")
Age.Sex.SV.chip_Table.annotated <- Age.Sex.SV.chip_Table.annotated[order(Age.Sex.SV.chip_Table.annotated$Nominal_P),]

#Grabbing the Volcano hits:
LM_Age.Sex.SV.chip_Hits <- Age.Sex.SV.chip_Table.annotated[which(abs(Age.Sex.SV.chip_Table.annotated$Delta_Beta)>0.05 & Age.Sex.SV.chip_Table.annotated$Nominal_P<4e-6),]

#Let's order by Nominal_P:
LM_Age.Sex.SV.chip_Hits = LM_Age.Sex.SV.chip_Hits[order(LM_Age.Sex.SV.chip_Hits$Nominal_P),]
rownames(LM_Age.Sex.SV.chip_Hits) = c()
str(LM_Age.Sex.SV.chip_Hits)
head(LM_Age.Sex.SV.chip_Hits)
```

Age-associated hits: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3482848/
Non-tissue specific hits: https://epigeneticsandchromatin.biomedcentral.com/articles/10.1186/s13072-018-0191-3

```{r}
#Reorder row index.
rownames(Age.Sex.SV.chip_Table.annotated) <- NULL

#Look at hits based on candidate genes.
head(Age.Sex.SV.chip_Table.annotated[which(Age.Sex.SV.chip_Table.annotated$UCSC_RefGene_Name == "ELOVL2"),]) #First ELOVL2 hit == row 278.
head(Age.Sex.SV.chip_Table.annotated[which(Age.Sex.SV.chip_Table.annotated$UCSC_RefGene_Name == "EDARADD"),]) #First EDARADD hit == row 111292.
head(Age.Sex.SV.chip_Table.annotated[which(Age.Sex.SV.chip_Table.annotated$UCSC_RefGene_Name == "TOM1L1"),]) #First TOM1L1 hit == row 2140.
head(Age.Sex.SV.chip_Table.annotated[which(Age.Sex.SV.chip_Table.annotated$UCSC_RefGene_Name == "NPTX2"),]) #First NPTX2 hit == row 8828.
```


###EWAS Model 5.1: AMD samples on Age + Sex + SV + chip.

AMD samples only with sex, SV (cell type) and chip as covariates

```{r}
#Load all the objects.
load("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/AMD_SVA_M_values.funnorm.RData") 

dim(AMD_pData) #44 samples.
dim(M_values.funnorm.filt) #425456 probes.

AMD_pData$Disease_State <- as.factor(AMD_pData$Disease_State)
AMD_pData$Sex <- as.factor(AMD_pData$Sex)
AMD_pData$Row <- as.factor(AMD_pData$Row)
AMD_pData$Chip <- as.factor(AMD_pData$Chip)
AMD_pData$Age <- as.numeric(AMD_pData$Age)

str(AMD_pData)

#Check order.
identical(rownames(AMD_pData), colnames(M_values.funnorm.filt)) #TRUE. 

#Sanity check - there should be no NAs or infinite numbers - which could be a result of logit transformation of 0 or 1 beta values. 
all(complete.cases(M_values.funnorm.filt)) == "TRUE" #TRUE - meaning no NA or infinite numbers. 

#Subset AMD samples only.
AMD <- subset(AMD_pData, Disease_State == "age-related macular degeneration")
dim(AMD) #25 samples.

AMD_M_values.funnorm.filt <- M_values.funnorm.filt[, colnames(M_values.funnorm.filt) %in% rownames(AMD)]
dim(AMD_M_values.funnorm.filt) #425456 probes, 25 samples.

rm(AMD_pData)
rm(M_values.funnorm.filt)
```

```{r, eval=FALSE}
library(pbapply) #Progress bar for apply functions.

#EWAS on Age - All samples + Sex + SV + Chip.
#LM: Need to use transformed M-values instead of beta values as it is more statistically sound.
AMD.only_Age.Sex.SV.chip_LM_pval <- pbsapply(1:nrow(AMD_M_values.funnorm.filt), function(CpG){
  meta <- AMD
  meta$Mval <- AMD_M_values.funnorm.filt[CpG,]
  mod_AMD.only_Age.Sex.SV.chip <- lm(Mval ~ Age + Sex + SV + Chip, data = meta) #Only Sex + SV + Chip as covariate.
  coef(summary(mod_AMD.only_Age.Sex.SV.chip))[2,4]}) #Returns nominal p-value for Age for model at each CpG.
head(AMD.only_Age.Sex.SV.chip_LM_pval)

save(AMD.only_Age.Sex.SV.chip_LM_pval, file = "~/KoborLab/kobor_space/kendrix/macular_degeneration/data/AMD.only_Age.Sex.SV.chip_LM_pval.RData")
```

```{r, fig.align='center'}
load("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/AMD.only_Age.Sex.SV.chip_LM_pval.RData")

#Inspect p-value distribution for model.
pvalue_dist_AMD.only_Age.Sex.SV.chip <- data.frame(CpG = rownames(AMD_M_values.funnorm.filt), Nominal_P = AMD.only_Age.Sex.SV.chip_LM_pval)
ggplot(pvalue_dist_AMD.only_Age.Sex.SV.chip, aes(Nominal_P)) + 
  geom_histogram(fill = "grey90", color = "black") + 
  theme_classic() + xlab("Nominal P Value") + 
  ylim(0, 20000) + 
  xlim(min(AMD.only_Age.Sex.SV.chip_LM_pval), max(AMD.only_Age.Sex.SV.chip_LM_pval))
#Not right-skewed. Distribution is a little even. 

#Multiple test correction with FDR.
AMD_M_values.funnorm.filt <- as.data.frame(AMD_M_values.funnorm.filt)
Multi_test_corr_relaxed <- p.adjust(AMD.only_Age.Sex.SV.chip_LM_pval, method = "fdr", n = length(AMD.only_Age.Sex.SV.chip_LM_pval))

#Looking at FDR thresholds for hits:
dim(as.data.frame(AMD_M_values.funnorm.filt)[which(Multi_test_corr_relaxed <= 0.05),]) #0 at 0.05.
dim(as.data.frame(AMD_M_values.funnorm.filt)[which(Multi_test_corr_relaxed <= 0.1),]) #0 at 0.1.
dim(as.data.frame(AMD_M_values.funnorm.filt)[which(Multi_test_corr_relaxed <= 0.2),]) #2 at 0.2.

#Looking at top hits by nominal P:
pvalue_dist_AMD.only_Age.Sex.SV.chip <- pvalue_dist_AMD.only_Age.Sex.SV.chip[order(pvalue_dist_AMD.only_Age.Sex.SV.chip$Nominal_P),]
head(pvalue_dist_AMD.only_Age.Sex.SV.chip)

#Load 450K annotation data.
load("~/KoborLab/kobor_space/shared_coding_resource/Illumina_EPIC/EPIC_Annotation_Complete.RData")
head(EPIC_Annotation_Complete)

dim(hits_CpGs <- pvalue_dist_AMD.only_Age.Sex.SV.chip[which(pvalue_dist_AMD.only_Age.Sex.SV.chip$Nominal_P < 1e-6),]) #2 hits.
hits <- EPIC_Annotation_Complete[which(EPIC_Annotation_Complete$Name%in%hits_CpGs$CpG),]
hits$UCSC_RefGene_Name
```

```{r, eval=FALSE}
#Delta beta.
#Using Maggie's code for deltabeta:
deltabeta <- function(df, mainvar, covar1 = NULL, covar2 = NULL, covar3 = NULL, covar4 = NULL, covar5 = NULL) {
  # Calculating delta beta of the main variable of interest (mainvar), with up to 5 possible covariates (covar)
  # mainvar should be a vector of continuous variable
  # all covars should also be vectors
  # df = dataframe or matrix of beta values
  # output is a vector of delta beta values
  sd=sd(mainvar)
  qt <-
    range <- max(mainvar, na.rm = T) - min(mainvar, na.rm = T)
  dB <- vector(mode = "numeric", length = nrow(df))
  names(dB) <- rownames(df)
  for (i in 1:nrow(df)) {
    beta <- df[i, ]
    if (is.null(covar1)) {
      mod <- lm(beta ~ mainvar)
    } else if (is.null(covar2)) {
      mod <- lm(beta ~ mainvar + covar1)
    } else if (is.null(covar3)) {
      mod <- lm(beta ~ mainvar + covar1 + covar2)
    } else if (is.null(covar4)) {
      mod <- lm(beta ~ mainvar + covar1 + covar2 + covar3)
    } else if (is.null(covar5)) {
      mod <- lm(beta ~ mainvar + covar1 + covar2 + covar3 + covar4)
    } else {
      mod <- lm(beta ~ mainvar + covar1 + covar2 + covar3 + covar4 + covar5)
    }
    slope <- mod$coefficients[2]
    dB[i] <- as.numeric(slope*range)
  }
  dB
}

AMD_betas.funnorm.filt <- m2beta(AMD_M_values.funnorm.filt)

delta_beta_AMD.only_Age.Sex.SV.chip_fixed <- deltabeta(as.matrix(AMD_betas.funnorm.filt), AMD$Age, covar1 = AMD$Sex, covar2 = AMD$SV, covar3 = AMD$Chip)
length(delta_beta_AMD.only_Age.Sex.SV.chip_fixed)
summary(delta_beta_AMD.only_Age.Sex.SV.chip_fixed)

save(delta_beta_AMD.only_Age.Sex.SV.chip_fixed, file = "~/KoborLab/kobor_space/kendrix/macular_degeneration/data/DB_AMD.only_Age.Sex.SV.chip_fixed.RData")
```


###EWAS Model 6: All samples on Age + Chip.

Chip as covariate.

```{r}
#Load all the objects.
load("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/AMD_SVA_M_values.funnorm.RData") 

dim(AMD_pData) #44 samples.
dim(M_values.funnorm.filt) #425456 probes.

AMD_pData$Disease_State <- as.factor(AMD_pData$Disease_State)
AMD_pData$Sex <- as.factor(AMD_pData$Sex)
AMD_pData$Row <- as.factor(AMD_pData$Row)
AMD_pData$Chip <- as.factor(AMD_pData$Chip)
AMD_pData$Age <- as.numeric(AMD_pData$Age)

str(AMD_pData)

#Check order.
identical(rownames(AMD_pData), colnames(M_values.funnorm.filt)) #TRUE. 

#Sanity check - there should be no NAs or infinite numbers - which could be a result of logit transformation of 0 or 1 beta values. 
all(complete.cases(M_values.funnorm.filt)) == "TRUE" #TRUE - meaning no NA or infinite numbers. 
```

```{r, eval=FALSE}
library(pbapply) #Progress bar for apply functions.

#EWAS on Age - All samples + Chip.
#LM: Need to use transformed M-values instead of beta values as it is more statistically sound.
Age.chip_LM_pval <- pbsapply(1:nrow(M_values.funnorm.filt), function(CpG){
  meta <- AMD_pData
  meta$Mval <- M_values.funnorm.filt[CpG,]
  mod_Age.chip <- lm(Mval ~ Age + Chip, data = meta) #Only Chip as covariate.
  coef(summary(mod_Age.chip))[2,4]}) #Returns nominal p-value for Age for model at each CpG.
head(Age.chip_LM_pval)

save(Age.chip_LM_pval, file = "~/KoborLab/kobor_space/kendrix/macular_degeneration/data/Age.chip_LM_pval.RData")
```

```{r, fig.align='center'}
load("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/Age.chip_LM_pval.RData")

#Inspect p-value distribution for model.
pvalue_dist_Age.chip <- data.frame(CpG = rownames(M_values.funnorm.filt), Nominal_P = Age.chip_LM_pval)
ggplot(pvalue_dist_Age.chip, aes(Nominal_P)) + 
  geom_histogram(fill = "grey90", color = "black") + 
  theme_classic() + xlab("Nominal P Value") + 
  ylim(0, 20000) + 
  xlim(min(Age.chip_LM_pval), max(Age.chip_LM_pval))
#Not right-skewed. Distribution is a little even. 

#Multiple test correction with FDR.
M_values.funnorm.filt <- as.data.frame(M_values.funnorm.filt)
Multi_test_corr_relaxed <- p.adjust(Age.chip_LM_pval, method = "fdr", n = length(Age.chip_LM_pval))

#Looking at FDR thresholds for hits:
dim(as.data.frame(M_values.funnorm.filt)[which(Multi_test_corr_relaxed <= 0.05),]) #0 at 0.05.
dim(as.data.frame(M_values.funnorm.filt)[which(Multi_test_corr_relaxed <= 0.1),]) #0 at 0.1.
dim(as.data.frame(M_values.funnorm.filt)[which(Multi_test_corr_relaxed <= 0.2),]) #32 at 0.2.

#Looking at top hits by nominal P:
pvalue_dist_Age.chip <- pvalue_dist_Age.chip[order(pvalue_dist_Age.chip$Nominal_P),]
head(pvalue_dist_Age.chip)

#Load 450K annotation data.
load("~/KoborLab/kobor_space/shared_coding_resource/Illumina_EPIC/EPIC_Annotation_Complete.RData")
head(EPIC_Annotation_Complete)

dim(hits_CpGs <- pvalue_dist_Age.chip[which(pvalue_dist_Age.chip$Nominal_P < 1e-6),]) #1 hits.
hits <- EPIC_Annotation_Complete[which(EPIC_Annotation_Complete$Name%in%hits_CpGs$CpG),]
hits$UCSC_RefGene_Name
```

```{r, eval=FALSE}
#Delta beta.
#Using Maggie's code for deltabeta:
deltabeta <- function(df, mainvar, covar1 = NULL, covar2 = NULL, covar3 = NULL, covar4 = NULL, covar5 = NULL) {
  # Calculating delta beta of the main variable of interest (mainvar), with up to 5 possible covariates (covar)
  # mainvar should be a vector of continuous variable
  # all covars should also be vectors
  # df = dataframe or matrix of beta values
  # output is a vector of delta beta values
  sd=sd(mainvar)
  qt <-
    range <- max(mainvar, na.rm = T) - min(mainvar, na.rm = T)
  dB <- vector(mode = "numeric", length = nrow(df))
  names(dB) <- rownames(df)
  for (i in 1:nrow(df)) {
    beta <- df[i, ]
    if (is.null(covar1)) {
      mod <- lm(beta ~ mainvar)
    } else if (is.null(covar2)) {
      mod <- lm(beta ~ mainvar + covar1)
    } else if (is.null(covar3)) {
      mod <- lm(beta ~ mainvar + covar1 + covar2)
    } else if (is.null(covar4)) {
      mod <- lm(beta ~ mainvar + covar1 + covar2 + covar3)
    } else if (is.null(covar5)) {
      mod <- lm(beta ~ mainvar + covar1 + covar2 + covar3 + covar4)
    } else {
      mod <- lm(beta ~ mainvar + covar1 + covar2 + covar3 + covar4 + covar5)
    }
    slope <- mod$coefficients[2]
    dB[i] <- as.numeric(slope*range)
  }
  dB
}

betas.funnorm.filt <- m2beta(M_values.funnorm.filt)

delta_beta_Age.chip_fixed <- deltabeta(as.matrix(betas.funnorm.filt), AMD_pData$Age, covar1 = AMD_pData$Chip)
length(delta_beta_Age.chip_fixed)
summary(delta_beta_Age.chip_fixed)

save(delta_beta_Age.chip_fixed, file = "~/KoborLab/kobor_space/kendrix/macular_degeneration/data/DB_Age.chip_fixed.RData")
```

```{r, fig.align='center'}
##3. Linear Model: Volcano Plot
#Volcano to examine hits (for DB, see below chunks):
load("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/DB_Age.chip_fixed.RData")

#Call Volcano (Nominal p Version, modified from Rachel's code):
source("/home/BCRICWH.LAN/dlin/KoborLab/kobor_space/cake/home/dlin/Volcano_DL_Nominal.R")

#After running the last 2 chunks, make a summary table with CpG, Nominal_P, FDR, and Delta Beta.
Age.chip_Table <- data.frame(rownames(M_values.funnorm.filt), Age.chip_LM_pval, Multi_test_corr_relaxed, delta_beta_Age.chip_fixed)
colnames(Age.chip_Table) = c("CpG", "Nominal_P", "FDR", "Delta_Beta")
identical(as.character(rownames(Age.chip_Table)), as.character(Age.chip_Table$CpG)) #TRUE.

#Looking at top hits quickly without considering DB:
head(Age.chip_Table[order(Age.chip_Table$Nominal_P),],10)

##Setting a threshold of 0.05DB, 5e-6 Nominal P (scale to 0.60DB):
makeVolcano_nominal(Age.chip_Table$Nominal_P, Age.chip_Table$Delta_Beta, 0.05, 5e-6, "DNAm changes", 0.5) #at 5e-6: 9 Hypermethylated, 0 Hypomethylated

#What are these hits?
#First make an annotated table - load 450K manifest.
load("~/KoborLab/kobor_space/shared_coding_resource/Illumina_EPIC/EPIC_Annotation_Complete.RData")
head(EPIC_Annotation_Complete)

Age.chip_Table.annotated = merge(Age.chip_Table, EPIC_Annotation_Complete[,c("Name", "CHR", "Strand", "UCSC_RefGene_Name", "UCSC_RefGene_Group")], by.x = "CpG", by.y = "Name", all = FALSE)
colnames(Age.chip_Table.annotated)[5:6] = c("Chromosome", "Coordinate")
Age.chip_Table.annotated <- Age.chip_Table.annotated[order(Age.chip_Table.annotated$Nominal_P),]

#Grabbing the Volcano hits:
LM_Age.chip_Hits <- Age.chip_Table.annotated[which(abs(Age.chip_Table.annotated$Delta_Beta)>0.05 & Age.chip_Table.annotated$Nominal_P<5e-6),]

#Let's order by Nominal_P:
LM_Age.chip_Hits = LM_Age.chip_Hits[order(LM_Age.chip_Hits$Nominal_P),]
rownames(LM_Age.chip_Hits) = c()
str(LM_Age.chip_Hits)
head(LM_Age.chip_Hits)
```

Age-associated hits: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3482848/
Non-tissue specific hits: https://epigeneticsandchromatin.biomedcentral.com/articles/10.1186/s13072-018-0191-3

```{r}
#Reorder row index.
rownames(Age.chip_Table.annotated) <- NULL

#Look at hits based on candidate genes.
head(Age.chip_Table.annotated[which(Age.chip_Table.annotated$UCSC_RefGene_Name == "ELOVL2"),]) #First ELOVL2 hit == row 278.
head(Age.chip_Table.annotated[which(Age.chip_Table.annotated$UCSC_RefGene_Name == "EDARADD"),]) #First EDARADD hit == row 111292.
head(Age.chip_Table.annotated[which(Age.chip_Table.annotated$UCSC_RefGene_Name == "TOM1L1"),]) #First TOM1L1 hit == row 2140.
head(Age.chip_Table.annotated[which(Age.chip_Table.annotated$UCSC_RefGene_Name == "NPTX2"),]) #First NPTX2 hit == row 8828.
```


###EWAS Model 7: Candidate approach to look at ELOVL2.

```{r}
#Load all the objects.
load("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/AMD_SVA_M_values.funnorm.RData") 

dim(AMD_pData) #44 samples.
dim(M_values.funnorm.filt) #425456 probes.

AMD_pData$Disease_State <- as.factor(AMD_pData$Disease_State)
AMD_pData$Sex <- as.factor(AMD_pData$Sex)
AMD_pData$Row <- as.factor(AMD_pData$Row)
AMD_pData$Chip <- as.factor(AMD_pData$Chip)

str(AMD_pData)

#Check order.
identical(rownames(AMD_pData), colnames(M_values.funnorm.filt)) #TRUE. 

#Sanity check - there should be no NAs or infinite numbers - which could be a result of logit transformation of 0 or 1 beta values. 
all(complete.cases(M_values.funnorm.filt)) == "TRUE" #TRUE - meaning no NA or infinite numbers. 

#Load 450K manifest.
load("~/KoborLab/kobor_space/shared_coding_resource/Illumina_EPIC/EPIC_Annotation_Complete.RData")
head(EPIC_Annotation_Complete)

#Pull out ELOVL2-specific CpG sites.
ELOVL2 <- EPIC_Annotation_Complete[which(EPIC_Annotation_Complete$UCSC_RefGene_Name == "ELOVL2"),]

#Subset ELOVL2-specific CpG sites.
M_values.funnorm.filt <- M_values.funnorm.filt[which(rownames(M_values.funnorm.filt) %in% rownames(ELOVL2)),]
```

```{r, fig.align='center'}
library(pbapply) #Progress bar for apply functions.

#EWAS on Age - All samples.
#LM: Need to use transformed M-values instead of beta values as it is more statistically sound.
Age.candidate_LM_pval <- pbsapply(1:nrow(M_values.funnorm.filt), function(CpG){
  meta <- AMD_pData
  meta$Mval <- M_values.funnorm.filt[CpG,]
  mod_Age.candidate.row <- lm(Mval ~ Age + SV, data = meta) 
  coef(summary(mod_Age.candidate.row))[2,4]}) #Returns nominal p-value for Age for model at each CpG.
head(Age.candidate_LM_pval)

#Inspect p-value distribution for model.
pvalue_dist_Age.candidate <- data.frame(CpG = rownames(M_values.funnorm.filt), Nominal_P = Age.candidate_LM_pval)
qqnorm(pvalue_dist_Age.candidate$Nominal_P)
#Right skewed Q-Q plot.
```


---------------------------------------------------------------------------------------------------------------------------


##Epigenetic clocks


###Step 1: Prepare data to run Horvath, Hannum and PhenoAge clocks.

This is the site with information pertaining to the Hovarth clock input. Note that the site runs all three clocks: Horvath, Hannum and PhenoAge clocks (among other clocks - refer to Horvath’s manual (Location: ~KoborLab/kobor_space/kendrix/macular_degeneration/ManualEpigeneticClock3.pdf)) simultaneously with the same input.

Input: Data frame of betas from noob-normalised MSet object with Sample IDs as columns.

```{r, results='hide'}
#Horvath data prep function. 
horvathPrep <- function(dat){
  dat <- as.data.frame(dat)
  dat0= cbind(rownames(dat), dat) #need col 1 to be CpG probe ID
  datMiniAnnotation=read.csv("~/KoborLab/kobor_space/shared_coding_resource/Horvath_Age_Prediction/datMiniAnnotation3.csv") #get from horvath website above
  match1=match(datMiniAnnotation[,1], dat0[,1] )
  dat0Reduced=dat0[match1,]
  dat0Reduced[,1]=as.character(dat0Reduced[,1])
  dat0Reduced[is.na(match1),1]= as.character(datMiniAnnotation[is.na(match1),1])
  datout=data.frame(dat0Reduced)
  # make sure you output numeric variables...
  for (i in 2:dim(datout)[[2]]  ){datout[,i]= as.numeric(as.character(gsub(x=datout[,i],pattern="\"",replacement=""))) }
  colnames(datout)[1] <- "Probe"                         
  return(datout)}

#Prepare methylation data for Horvath clock. 
betas.noob <- getBeta(AMD_MSet.noob)
AMD_betas.Horvath <- horvathPrep(betas.noob)

#Match colnames to AMD_samplesheet.
colnames(AMD_betas.Horvath) <- gsub("\\.", " ", colnames(AMD_betas.Horvath))
identical(colnames(AMD_betas.Horvath)[2:45], sampleNames(AMD_ExtendedRGSet)) #Sample order matches.

write.table(AMD_betas.Horvath,"~/KoborLab/kobor_space/kendrix/macular_degeneration/data/AMD_betas.Horvath.csv", row.names = F, sep = "," )
```

For ‘Advanced Blood Analysis’ (more columns in output including Hannum & Weidner clocks, as well as cell type estimate, etc. you need to create an annotation file to be used with calculating epigenetic age. We need three variables as well as the first column representing the sample names. - Column 1: Sample ID which contains a list of the same ordered names as the methylation file - Column 2: Chronological age as an integer - Column 3: Titled “Female”, male = 0 and female = 1. This is used to validate gender labels - Column 4: “Tissue”, from [Horvath’s PDF tutorial](https://github.com/kobor-lab/Methylation-Array-Analysis/blob/master/analysis%20scripts/DNAm%20Age%20-%20Horvath/Horvath_details.pdf).

```{r, results='hide'}
#Make sample file for Advanced Analysis in Blood. 
Sample_Annotation <- pData(AMD_MSet.noob)
head(Sample_Annotation)

Sample_Annotation <- Sample_Annotation[, c("Sample_Name", "Age", "Sex", "Tissue")]
Sample_Annotation$Sex <- gsub("F", "1", gsub("M", "0", Sample_Annotation$Sex))
colnames(Sample_Annotation)[3] <- "Female"

str(Sample_Annotation)
```

```{r}
identical(rownames(Sample_Annotation), colnames(AMD_betas.Horvath)[2:45]) #TRUE.
write.table(Sample_Annotation,"~/KoborLab/kobor_space/kendrix/macular_degeneration/data/Sample_Annotation_Horvath.csv", row.names = F, sep = "," )
```


###Step 2: Explore output of Horvath et al. epigenetics clocks.

After the epigenetic ages are calculated and the output is obtained from the Horvath team, upload the output to the server to be visualised.

```{r}
#Load necessary objeects.
load("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/AMD_ExtendedRGSet.RData")
load("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/AMD_MSet.noob.RData")

AMD_samplesheet <- read.csv("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/idats/AMD_project/AMD_samplesheet.csv", header = TRUE)
```

```{r}
AMD_Epigenetic_Age <- read.csv(file = "~/KoborLab/kobor_space/kendrix/macular_degeneration/data/AMD_betas.output.csv", row.names = 1)
rownames(AMD_Epigenetic_Age) <- AMD_Epigenetic_Age$Sample_Name

#Add Epigenetic Age information to RGSet. 
identical(rownames(pData(AMD_ExtendedRGSet)), rownames(AMD_Epigenetic_Age))
AMD_pData <- as.data.frame(pData(AMD_ExtendedRGSet))
AMD_pData <- join(AMD_pData, AMD_Epigenetic_Age, by = "Sample_Name")
rownames(AMD_pData) <- AMD_pData$Sample_Name
identical(rownames(pData(AMD_ExtendedRGSet)), rownames(AMD_pData)) #Check to make sure the order of the samples that are merged is correct.
```


###Step 3: Horvath clock.

[The Horvath clock](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4015143/) is a pan-tissue epigenetic clock that will predict the DNAm age of tissues based on 353 CpG sites that were developed from 8,000 samples from 82 datasets.

Note that even though the Horvath clock was trained using multiple tissues, none of the tissues are retina tissues that are in this dataset.

Error: +/- 3.6 years.

```{r, fig.align='center'}
#Subset relevant epigenetic age variables. 
AMD_Epigenetic_Age_Horvath <- AMD_pData[, c("Sample_Name", "Sample_Group", "Array", "Slide", "Sex", "predictedGender", "Tissue", "predictedTissue", "Age", "DNAmAge", "AgeAccelerationDiff", "AgeAccelerationResidual")] 

#Create function to plot linear regression.
ggplotRegression <- function (fit) {

require(ggplot2)

ggplot(fit$model, aes_string(x = names(fit$model)[2], y = names(fit$model)[1])) + 
  geom_point(aes(colour = AMD_Epigenetic_Age_Horvath$Sex, shape = AMD_Epigenetic_Age_Horvath$Sample_Group)) +
  guides(size = FALSE) +
  stat_smooth(method = "lm", col = "red") 
}

#Regression plot of Horvath predicted DNAmAge against reported age:
AMD_HO_plot <- lm(DNAmAge ~ Age, data = AMD_Epigenetic_Age_Horvath)
ggplotRegression(AMD_HO_plot) + labs(x = "Reported age", y = "Horvath predicted age", caption = "Comparing reported age and predicted age using Horvath epigenetic clock") + 
  scale_colour_manual(name = "Sex", values = c("#990000", "#2c7dab"), labels = c("Female", "Male")) +
  scale_shape_manual(name = "Disease State", values = c(20, 23), labels = c("AMD", "Normal")) +
  stat_cor(method = "spearman") +
  theme_bw() + theme(panel.border = element_blank(), 
                     panel.grid.major = element_blank(), 
                     panel.grid.minor = element_blank(), 
                     axis.line = element_line(colour = "black"), 
                     axis.text = element_text(), 
                     axis.title = element_text(size = 8), 
                     plot.caption = element_text(hjust = 0.5, size = rel(1)))
```

```{r, fig.align='center'}
#Plot of overall disease state vs control:
AMD_Epigenetic_Age_Horvath$Sample_Group <- factor(AMD_Epigenetic_Age_Horvath$Sample_Group)
ggplot(data = AMD_Epigenetic_Age_Horvath, 
       aes(x = Sample_Group, y = AgeAccelerationResidual, fill = Sample_Group)) +
  geom_boxplot(position = position_dodge(0.7), width = 0.5, outlier.shape = NA) +
  geom_jitter(aes(fill = Sample_Group), size = 2, shape = 21, alpha = 0.7, 
              position = position_jitterdodge(dodge.width = 0.75, jitter.width = 0.3)) + 
  xlab("Disease State") + ylab("Horvath Age Acceleration Residual") + 
  scale_x_discrete(breaks = c("age-related macular degeneration","normal"), 
                   labels = c("Age-Related Macular Degeneration", "Normal")) + 
  scale_fill_manual(values = c("#77284e", "#ffffff")) +
  theme_classic() + theme(
              panel.border = element_blank(),
              panel.background = element_blank(),
              plot.title = element_text(size = 14, family = "Tahoma", face = "bold"),
              text = element_text(family = "Tahoma"),
              axis.title = element_text(face = "bold"),
              axis.text.x = element_text(colour = "black", size = 11),
              axis.text.y = element_text(colour = "black", size = 9),
              axis.line = element_line(size = 0.5, colour = "black"),
              legend.position = "none")
```

```{r}
AMD <- subset(AMD_Epigenetic_Age_Horvath, Sample_Group == "age-related macular degeneration")
normal <- subset(AMD_Epigenetic_Age_Horvath, Sample_Group == "normal")

var.test(AMD$AgeAccelerationResidual, normal$AgeAccelerationResidual)
```


```{r, fig.align='center'}
#Plot of disease state vs control that is stratified by sex:
AMD_Epigenetic_Age_Horvath$Sex <- factor(AMD_Epigenetic_Age_Horvath$Sex)
ggplot(data = AMD_Epigenetic_Age_Horvath, 
       aes(x = Sample_Group, y = AgeAccelerationResidual, fill = Sex)) + 
  geom_boxplot(position = position_dodge(0.7), width = 0.5, outlier.shape = NA) +
  geom_jitter(aes(fill = Sex), size = 2, shape = 21, alpha = 0.7, 
              position = position_jitterdodge(dodge.width = 0.75, jitter.width = 0.3)) + 
  xlab("Disease State") + ylab("Horvath Age Acceleration Residual") + 
  scale_x_discrete(breaks = c("age-related macular degeneration","normal"), 
                   labels = c("AMD", "Normal")) + 
  scale_fill_manual(values = c("#990000", "#2c7dab")) +
  theme_classic() + theme(
              panel.border = element_blank(),
              panel.background = element_blank(),
              plot.title = element_text(size = 14, family = "Tahoma", face = "bold"),
              text = element_text(family = "Tahoma"),
              axis.title = element_text(face = "bold"),
              axis.text.x = element_text(colour = "black", size = 11),
              axis.text.y = element_text(colour = "black", size = 9),
              axis.line = element_line(size = 0.5, colour = "black"))
```

```{r, fig.align='center'}
#Calculate mean and difference for Bland-Altman plot.
AMD_Epigenetic_Age_Horvath$Mean <- (AMD_Epigenetic_Age_Horvath$DNAmAge + AMD_Epigenetic_Age_Horvath$Age)/2
AMD_Epigenetic_Age_Horvath$Difference <- AMD_Epigenetic_Age_Horvath$DNAmAge - AMD_Epigenetic_Age_Horvath$Age

ggplot(AMD_Epigenetic_Age_Horvath, aes(Mean, Difference)) + geom_point(shape = 0, size = 3) + ylim(-60, 25) + xlab("Mean (years)") + ylab("Difference (years)") + geom_hline(yintercept = 14.76577) + geom_hline(yintercept = -14.76577) + theme_classic()
```


```{r}
#Determine statistical significance between disease state vs control with ANOVA.
summary(lm(DNAmAge ~ Sample_Group + Sex + Sex*Sample_Group, data = AMD_Epigenetic_Age_Horvath))
summary(aov(DNAmAge ~ Sample_Group + Sex + Sex*Sample_Group, data = AMD_Epigenetic_Age_Horvath))

summary(lm(AgeAccelerationResidual ~ Sample_Group + Sex + Sex*Sample_Group, data = AMD_Epigenetic_Age_Horvath))
summary(aov(AgeAccelerationResidual ~ Sample_Group + Sex + Sex*Sample_Group, data = AMD_Epigenetic_Age_Horvath))
```

```{r}
#Determine the statistical significance male AMD vs. normal. 
Horvath_males <- subset(AMD_Epigenetic_Age_Horvath, Sex == "M")

#Preliminary checks before performing t-test.

#Test for normality:
#The Shapiro-Wilk test to check if the data of interest is normality distribution. 
#Null hypothesis = The data are normally distribution.
with(Horvath_males, shapiro.test(AgeAccelerationResidual[Sample_Group == "age-related macular degeneration"])) #p-value = 0.2265 which is greater than 0.05, implying the distribution of the data is not significantly different from normal distribution. In other words, assume normality.
with(Horvath_males, shapiro.test(AgeAccelerationResidual[Sample_Group == "normal"])) #p-value = 0.182 which is greater than 0.05, implying the distribution of the data is not significantly different from normal distribution. In other words, assume normality.

#Test for distribution of variances.
#Use F-test to test for homogeneity of variances. 
var.test(AgeAccelerationResidual ~ Sample_Group, data = Horvath_males) #p-value = 0.6034, which is greater than 0.05, implying no significant difference between the variances of both sets of data. 

#Since both sets of data show normality and equality between variances, we can do classic t-test that requires those assumptions of normality and variance. 
t.test(AgeAccelerationResidual ~ Sample_Group, data = Horvath_males, var.equal = TRUE)
#p-value = 0.3086, which is greater than 0.05. Therefore, the age-acceleration residual in AMD male is not statistically more signficant as compared to normal male.
```

```{r, fig.align='center'}
library(effects)

LM_Horvath_Residual <- lm(AgeAccelerationResidual ~ Sample_Group + Sex + Sex*Sample_Group, data = AMD_Epigenetic_Age_Horvath)

#Look at the interaction effects.
Disease_Sex_Interact <- as.data.frame(effect("Sample_Group*Sex", LM_Horvath_Residual, se = TRUE))

#Interaction plot.
ggplot(Disease_Sex_Interact, aes(x = Sample_Group, y = fit, group = Sex)) + 
  geom_line(size = 2, aes(color = Sex)) + 
  geom_ribbon(aes(ymin = fit-se, ymax = fit+se, fill = Sex),alpha = .2) + 
  scale_color_manual(values = c("#990000", "#2c7dab")) +
  ylab("Horvath Age Acceleration Residual") + xlab("Disease State") + 
  theme_bw() + 
  theme(text = element_text(size = 12),
        legend.text = element_text(size = 12),
        legend.direction = "horizontal",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        legend.position = "top")
```


###Step 4: Winsorized Horvath clock.

DNAm age acceleration residual data is winsorized (i.e. by shrinking outlying observations to the border of the main part of the data) before plotting.

```{r, fig.align='center'}
#Windsorize age acceleration data.
AMD_Epigenetic_Age_Horvath <- AMD_Epigenetic_Age_Horvath %>% mutate(Winz_AgeAccelResidual = winsorize(AgeAccelerationResidual))
```

```{r, fig.align='center'}
#Plot of overall disease state vs control:
AMD_Epigenetic_Age_Horvath$Sample_Group <- factor(AMD_Epigenetic_Age_Horvath$Sample_Group)
ggplot(data = AMD_Epigenetic_Age_Horvath, 
       aes(x = Sample_Group, y = Winz_AgeAccelResidual, fill = Sample_Group)) +
  geom_boxplot(position = position_dodge(0.7), width = 0.5, outlier.shape = NA) +
  geom_jitter(aes(fill = Sample_Group), size = 2, shape = 21, alpha = 0.7, 
              position = position_jitterdodge(dodge.width = 0.75, jitter.width = 0.3)) + 
  xlab("Disease State") + ylab("Winsorized Horvath Age Acceleration Residual") + 
  scale_x_discrete(breaks = c("age-related macular degeneration","normal"), 
                   labels = c("Age-Related Macular Degeneration", "Normal")) + 
  scale_fill_manual(values = c("#77284e", "#ffffff")) +
  theme_classic() + theme(
              panel.border = element_blank(),
              panel.background = element_blank(),
              plot.title = element_text(size = 14, family = "Tahoma", face = "bold"),
              text = element_text(family = "Tahoma"),
              axis.title = element_text(face = "bold"),
              axis.text.x = element_text(colour = "black", size = 11),
              axis.text.y = element_text(colour = "black", size = 9),
              axis.line = element_line(size = 0.5, colour = "black"),
              legend.position = "none")
```

```{r, fig.align='center'}
#Plot of disease state vs control that is stratified by sex:
AMD_Epigenetic_Age_Horvath$Sex <- factor(AMD_Epigenetic_Age_Horvath$Sex)
ggplot(data = AMD_Epigenetic_Age_Horvath, 
       aes(x = Sample_Group, y = Winz_AgeAccelResidual, fill = Sex)) + 
  geom_boxplot(position = position_dodge(0.7), width = 0.5, outlier.shape = NA) +
  geom_jitter(aes(fill = Sex), size = 2, shape = 21, alpha = 0.7, 
              position = position_jitterdodge(dodge.width = 0.75, jitter.width = 0.3)) + 
  xlab("Disease State") + ylab("Winsorized Horvath Age Accel Residual") + 
  scale_x_discrete(breaks = c("age-related macular degeneration","normal"), 
                   labels = c("AMD", "Normal")) + 
  scale_fill_manual(values = c("#990000", "#2c7dab")) +
  theme_classic() + theme(
              panel.border = element_blank(),
              panel.background = element_blank(),
              plot.title = element_text(size = 14, family = "Tahoma", face = "bold"),
              text = element_text(family = "Tahoma"),
              axis.title = element_text(face = "bold"),
              axis.text.x = element_text(colour = "black", size = 11),
              axis.text.y = element_text(colour = "black", size = 9),
              axis.line = element_line(size = 0.5, colour = "black"))
```

```{r}
#Determine statistical significance between disease state vs control that is stratified by sex with ANOVA.
#Compute the analysis of variance
summary(lm(Winz_AgeAccelResidual ~ Sample_Group + Sex + Sex*Sample_Group, data = AMD_Epigenetic_Age_Horvath))
summary(aov(Winz_AgeAccelResidual ~ Sample_Group + Sex + Sex*Sample_Group, data = AMD_Epigenetic_Age_Horvath))
```


###Step 5: Hannum clock.

Built from the whole blood of 656 human individuals, aged 19 to 101, this clock, developed by [Hannum et al.](https://www.sciencedirect.com/science/article/pii/S1097276512008933?via%3Dihub) looks at 71 CpG sites that are highly predictive of age. 

```{r, fig.align='center'}
#Subset relevant epigenetic age variables. 
AMD_Epigenetic_Age_Hannum <- AMD_pData[, c("Sample_Name", "Sample_Group", "Array", "Slide", "Sex", "predictedGender", "Tissue", "predictedTissue", "Age", "DNAmAgeHannum", "AgeAccelerationResidualHannum")] 

#Create function to plot linear regression.
ggplotRegression <- function (fit) {

require(ggplot2)

ggplot(fit$model, aes_string(x = names(fit$model)[2], y = names(fit$model)[1])) + 
  geom_point(aes(colour = AMD_Epigenetic_Age_Hannum$Sex, shape = AMD_Epigenetic_Age_Hannum$Sample_Group)) +
  stat_smooth(method = "lm", col = "red") 
}

#Regression plot of Hannum predicted DNAmAge against reported age:
AMD_HA_plot <- lm(DNAmAgeHannum ~ Age, data = AMD_Epigenetic_Age_Hannum)
ggplotRegression(AMD_HA_plot) + labs(x = "Reported age", y = "Hannum predicted age", caption = "Comparing reported age and predicted age using Hannum epigenetic clock") + 
  scale_colour_manual(name = "Sex", values = c("#990000", "#2c7dab")) +
  scale_shape_manual(name = "Disease State", values = c(20, 23), labels = c("AMD", "Normal")) +
  stat_cor(method = "spearman") +
  theme_bw() + theme(panel.border = element_blank(), 
                     panel.grid.major = element_blank(), 
                     panel.grid.minor = element_blank(), 
                     axis.line = element_line(colour = "black"), 
                     axis.text = element_text(), 
                     axis.title = element_text(size = 8), 
                     plot.caption = element_text(hjust = 0.5, size = rel(1)))
```

```{r, fig.align='center'}
#Plot of overall disease state vs control:
AMD_Epigenetic_Age_Hannum$Sample_Group <- factor(AMD_Epigenetic_Age_Hannum$Sample_Group)
ggplot(data = AMD_Epigenetic_Age_Hannum, 
       aes(x = Sample_Group, y = AgeAccelerationResidualHannum, fill = Sample_Group)) +
  geom_boxplot(position = position_dodge(0.7), width = 0.5, outlier.shape = NA) +
  geom_jitter(aes(fill = Sample_Group), size = 2, shape = 21, alpha = 0.7, 
              position = position_jitterdodge(dodge.width = 0.75, jitter.width = 0.3)) + 
  xlab("Disease State") + ylab("Hannum Age Acceleration Residual") + 
  scale_x_discrete(breaks = c("age-related macular degeneration","normal"), 
                   labels = c("Age-Related Macular Degeneration", "Normal")) + 
  scale_fill_manual(values = c("#77284e", "#ffffff")) +
  theme_classic() + theme(
              panel.border = element_blank(),
              panel.background = element_blank(),
              plot.title = element_text(size = 14, family = "Tahoma", face = "bold"),
              text = element_text(family = "Tahoma"),
              axis.title = element_text(face = "bold"),
              axis.text.x = element_text(colour = "black", size = 11),
              axis.text.y = element_text(colour = "black", size = 9),
              axis.line = element_line(size = 0.5, colour = "black"),
              legend.position = "none")
```

```{r, fig.align='center'}
#Plot of disease state vs control that is stratified by sex:
AMD_Epigenetic_Age_Hannum$Sex <- factor(AMD_Epigenetic_Age_Hannum$Sex)
ggplot(data = AMD_Epigenetic_Age_Hannum, 
       aes(x = Sample_Group, y = AgeAccelerationResidualHannum, fill = Sex)) + 
  geom_boxplot(position = position_dodge(0.7), width = 0.5, outlier.shape = NA) +
  geom_jitter(aes(fill = Sex), size = 1, shape = 21, alpha = 0.7, 
              position = position_jitterdodge(dodge.width = 0.75, jitter.width = 0.3)) + 
  xlab("Disease State") + ylab("Hannum Age Acceleration Residual") + 
  scale_x_discrete(breaks = c("age-related macular degeneration","normal"), 
                   labels = c("AMD", "Normal")) + 
  scale_fill_manual(values = c("#990000", "#2c7dab")) +
  theme_classic() + theme(
              panel.border = element_blank(),
              panel.background = element_blank(),
              plot.title = element_text(size = 14, family = "Tahoma", face = "bold"),
              text = element_text(family = "Tahoma"),
              axis.title = element_text(face = "bold"),
              axis.text.x = element_text(colour = "black", size = 11),
              axis.text.y = element_text(colour = "black", size = 9),
              axis.line = element_line(size = 0.5, colour = "black"))
```

```{r}
#Determine statistical significance between disease state vs control with ANOVA.
summary(lm(AgeAccelerationResidualHannum ~ Sample_Group + Sex + Sex*Sample_Group, data = AMD_Epigenetic_Age_Hannum))
summary(aov(AgeAccelerationResidualHannum ~ Sample_Group + Sex + Sex*Sample_Group, data = AMD_Epigenetic_Age_Hannum))
```


###Step 6: Winsorized Hannum clock.

DNAm age acceleration residual data is winsorized (i.e. by shrinking outlying observations to the border of the main part of the data) before plotting.

```{r, fig.align='center'}
#Windsorize age acceleration data.
AMD_Epigenetic_Age_Hannum <- AMD_Epigenetic_Age_Hannum %>% mutate(Winz_AgeAccelResidualHannum = winsorize(AgeAccelerationResidualHannum))
```

```{r, fig.align='center'}
#Plot of overall disease state vs control:
AMD_Epigenetic_Age_Hannum$Sample_Group <- factor(AMD_Epigenetic_Age_Hannum$Sample_Group)
ggplot(data = AMD_Epigenetic_Age_Hannum, 
       aes(x = Sample_Group, y = Winz_AgeAccelResidualHannum, fill = Sample_Group)) +
  geom_boxplot(position = position_dodge(0.7), width = 0.5, outlier.shape = NA) +
  geom_jitter(aes(fill = Sample_Group), size = 2, shape = 21, alpha = 0.7, 
              position = position_jitterdodge(dodge.width = 0.75, jitter.width = 0.3)) + 
  xlab("Disease State") + ylab("Winsorized Hannum Age Acceleration Residual") + 
  scale_x_discrete(breaks = c("age-related macular degeneration","normal"), 
                   labels = c("Age-Related Macular Degeneration", "Normal")) + 
  scale_fill_manual(values = c("#77284e", "#ffffff")) +
  theme_classic() + theme(
              panel.border = element_blank(),
              panel.background = element_blank(),
              plot.title = element_text(size = 14, family = "Tahoma", face = "bold"),
              text = element_text(family = "Tahoma"),
              axis.title = element_text(face = "bold"),
              axis.text.x = element_text(colour = "black", size = 11),
              axis.text.y = element_text(colour = "black", size = 9),
              axis.line = element_line(size = 0.5, colour = "black"),
              legend.position = "none")
```

```{r, fig.align='center'}
#Plot of disease state vs control that is stratified by sex:
AMD_Epigenetic_Age_Hannum$Sex <- factor(AMD_Epigenetic_Age_Hannum$Sex)
ggplot(data = AMD_Epigenetic_Age_Hannum, 
       aes(x = Sample_Group, y = Winz_AgeAccelResidualHannum, fill = Sex)) + 
  geom_boxplot(position = position_dodge(0.7), width = 0.5, outlier.shape = NA) +
  geom_jitter(aes(fill = Sex), size = 1, shape = 21, alpha = 0.7, 
              position = position_jitterdodge(dodge.width = 0.75, jitter.width = 0.3)) + 
  xlab("Disease State") + ylab("Winsorized Hannum Age Acceleration Residual") + 
  scale_x_discrete(breaks = c("age-related macular degeneration","normal"), 
                   labels = c("AMD", "Normal")) + 
  scale_fill_manual(values = c("#990000", "#2c7dab")) +
  theme_classic() + theme(
              panel.border = element_blank(),
              panel.background = element_blank(),
              plot.title = element_text(size = 14, family = "Tahoma", face = "bold"),
              text = element_text(family = "Tahoma"),
              axis.title = element_text(face = "bold"),
              axis.text.x = element_text(colour = "black", size = 11),
              axis.text.y = element_text(colour = "black", size = 9),
              axis.line = element_line(size = 0.5, colour = "black"))
```

```{r}
#Determine statistical significance between disease state vs control that is stratified by sex with ANOVA.
#Compute the analysis of variance
summary(lm(Winz_AgeAccelResidualHannum ~ Sample_Group + Sex + Sex*Sample_Group, data = AMD_Epigenetic_Age_Hannum))
summary(aov(Winz_AgeAccelResidualHannum ~ Sample_Group + Sex + Sex*Sample_Group, data = AMD_Epigenetic_Age_Hannum))
```


###Step 7: PhenoAge clock.

Developed from 513 CpG sites, this clock was built by [Levine et al.](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5940111/) to serve as prediction of a surrogate measure of "phenotypic age" that, in and of itself, differentiates morbidity and mortality risk among same-age individuals (optimized to predict a multi-system proxy of physiological dysregulation (phenotypic age)). The clock shares 41 CpGs in the Horvath clock and 5 CpGs in the Hannum clock (which was also present in the Horvath clock). 

```{r, fig.align='center'}
#Subset relevant epigenetic age variables. 
AMD_Epigenetic_PhenoAge <- AMD_pData[, c("Sample_Name", "Sample_Group", "Array", "Slide", "Sex", "predictedGender", "Tissue", "predictedTissue", "Age", "DNAmPhenoAge", "AgeAccelPheno")] 

#Create function to plot linear regression.
ggplotRegression <- function (fit) {

require(ggplot2)

ggplot(fit$model, aes_string(x = names(fit$model)[2], y = names(fit$model)[1])) + 
  geom_point(aes(colour = AMD_Epigenetic_PhenoAge$Sex, shape = AMD_Epigenetic_PhenoAge$Sample_Group)) +
  stat_smooth(method = "lm", col = "red") 
}

#Regression plot of PhenoAge predicted DNAmAge against reported age:
AMD_PhenoAge_plot <- lm(DNAmPhenoAge ~ Age, data = AMD_Epigenetic_PhenoAge)
ggplotRegression(AMD_PhenoAge_plot) + labs(x = "Reported age", y = "PhenoAge predicted age", caption = "Comparing reported age and predicted age using PhenoAge epigenetic clock") + 
  scale_colour_manual(name = "Sex", values = c("#990000", "#2c7dab")) +
  scale_shape_manual(name = "Disease State", values = c(20, 23), labels = c("AMD", "Normal")) +
  stat_cor(method = "spearman") +
  theme_bw() + theme(panel.border = element_blank(), 
                     panel.grid.major = element_blank(), 
                     panel.grid.minor = element_blank(), 
                     axis.line = element_line(colour = "black"), 
                     axis.text = element_text(), 
                     axis.title = element_text(size = 8), 
                     plot.caption = element_text(hjust = 0.5, size = rel(1)))
```

```{r, fig.align='center'}
#Plot of overall disease state vs control:
AMD_Epigenetic_PhenoAge$Sample_Group <- factor(AMD_Epigenetic_PhenoAge$Sample_Group)
ggplot(data = AMD_Epigenetic_PhenoAge, 
       aes(x = Sample_Group, y = AgeAccelPheno, fill = Sample_Group)) +
  geom_boxplot(position = position_dodge(0.7), width = 0.5, outlier.shape = NA) +
  geom_jitter(aes(fill = Sample_Group), size = 2, shape = 21, alpha = 0.7, 
              position = position_jitterdodge(dodge.width = 0.75, jitter.width = 0.3)) + 
  xlab("Disease State") + ylab("PhenoAge Acceleration Residual") + 
  scale_x_discrete(breaks = c("age-related macular degeneration","normal"), 
                   labels = c("Age-Related Macular Degeneration", "Normal")) + 
  scale_fill_manual(values = c("#77284e", "#ffffff")) +
  theme_classic() + theme(
              panel.border = element_blank(),
              panel.background = element_blank(),
              plot.title = element_text(size = 14, family = "Tahoma", face = "bold"),
              text = element_text(family = "Tahoma"),
              axis.title = element_text(face = "bold"),
              axis.text.x = element_text(colour = "black", size = 11),
              axis.text.y = element_text(colour = "black", size = 9),
              axis.line = element_line(size = 0.5, colour = "black"),
              legend.position = "none")
```

```{r, fig.align='center'}
#Plot of disease state vs control that is stratified by sex:
AMD_Epigenetic_PhenoAge$Sex <- factor(AMD_Epigenetic_PhenoAge$Sex)
ggplot(data = AMD_Epigenetic_PhenoAge, 
       aes(x = Sample_Group, y = AgeAccelPheno, fill = Sex)) + 
  geom_boxplot(position = position_dodge(0.7), width = 0.5, outlier.shape = NA) +
  geom_jitter(aes(fill = Sex), size = 1, shape = 21, alpha = 0.7, 
              position = position_jitterdodge(dodge.width = 0.75, jitter.width = 0.3)) + 
  xlab("Disease State") + ylab("PhenoAge Acceleration Residual") + 
  scale_x_discrete(breaks = c("age-related macular degeneration","normal"), 
                   labels = c("AMD", "Normal")) + 
  scale_fill_manual(values = c("#990000", "#2c7dab")) +
  theme_classic() + theme(
              panel.border = element_blank(),
              panel.background = element_blank(),
              plot.title = element_text(size = 14, family = "Tahoma", face = "bold"),
              text = element_text(family = "Tahoma"),
              axis.title = element_text(face = "bold"),
              axis.text.x = element_text(colour = "black", size = 11),
              axis.text.y = element_text(colour = "black", size = 9),
              axis.line = element_line(size = 0.5, colour = "black"))
```

```{r}
#Determine statistical significance between disease state vs control with ANOVA.
summary(lm(AgeAccelPheno ~ Sample_Group + Sex + Sex*Sample_Group, data = AMD_Epigenetic_PhenoAge))
summary(aov(AgeAccelPheno ~ Sample_Group + Sex + Sex*Sample_Group, data = AMD_Epigenetic_PhenoAge))
```


###Step 8: Skin & Blood clock.

The [Skin & Blood clock](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6075434/#r6) (based on 391 CpGs) was developed to accurately measure the age of human fibroblasts, keratinocytes, buccal cells, endothelial cells, skin and blood samples. This clock shares 45 CpGs (out of 71 CpGs) with the blood-based clock from Hannum (2013) and 60 CpGs (out of 353 CpGs) with the pan tissue clock from Horvath (2013). Despite this significant overlap, epigenetic age acceleration of the skin & blood clock exhibits only moderate correlations with corresponding epigenetic age acceleration measures by Horvath (2013) and Hannum (2013) (r=0.5 and r=0.59, p<1.E-110) in the blood samples from the Women's Health Initiative (BA23 study).

```{r, fig.align='center'}
#Subset relevant epigenetic age variables. 
AMD_Epigenetic_AgeSkinBlood <- AMD_pData[, c("Sample_Name", "Sample_Group", "Array", "Slide", "Sex", "predictedGender", "Tissue", "predictedTissue", "Age", "DNAmAgeSkinBloodClock")] 
AMD_Epigenetic_AgeSkinBlood$AgeAccelSkinBlood <- lm(DNAmAgeSkinBloodClock ~ Age, data = AMD_Epigenetic_AgeSkinBlood)$residuals

#Create function to plot linear regression.
ggplotRegression <- function (fit) {

require(ggplot2)

ggplot(fit$model, aes_string(x = names(fit$model)[2], y = names(fit$model)[1])) + 
  geom_point(aes(colour = AMD_Epigenetic_AgeSkinBlood$Sex, shape = AMD_Epigenetic_AgeSkinBlood$Sample_Group)) +
  stat_smooth(method = "lm", col = "red") 
}

#Regression plot of Skin & Blood clock predicted DNAmAge against reported age:
AMD_AgeSkinBlood_plot <- lm(DNAmAgeSkinBloodClock ~ Age, data = AMD_Epigenetic_AgeSkinBlood)
ggplotRegression(AMD_AgeSkinBlood_plot) + labs(x = "Reported age", y = "Skin & Blood predicted age", caption = "Comparing reported age and predicted age using Skin & Blood epigenetic clock") + 
  scale_colour_manual(name = "Sex", values = c("#990000", "#2c7dab")) +
  scale_shape_manual(name = "Disease State", values = c(20, 23), labels = c("AMD", "Normal")) +
  stat_cor(method = "spearman") +
  theme_bw() + theme(panel.border = element_blank(), 
                     panel.grid.major = element_blank(), 
                     panel.grid.minor = element_blank(), 
                     axis.line = element_line(colour = "black"), 
                     axis.text = element_text(), 
                     axis.title = element_text(size = 8), 
                     plot.caption = element_text(hjust = 0.5, size = rel(1)))
```

```{r, fig.align='center'}
#Plot of overall disease state vs control:
AMD_Epigenetic_AgeSkinBlood$Sample_Group <- factor(AMD_Epigenetic_AgeSkinBlood$Sample_Group)
ggplot(data = AMD_Epigenetic_AgeSkinBlood, 
       aes(x = Sample_Group, y = AgeAccelSkinBlood, fill = Sample_Group)) +
  geom_boxplot(position = position_dodge(0.7), width = 0.5, outlier.shape = NA) +
  geom_jitter(aes(fill = Sample_Group), size = 2, shape = 21, alpha = 0.7, 
              position = position_jitterdodge(dodge.width = 0.75, jitter.width = 0.3)) + 
  xlab("Disease State") + ylab("Skin & Blood Age Acceleration Residual") + 
  scale_x_discrete(breaks = c("age-related macular degeneration","normal"), 
                   labels = c("Age-Related Macular Degeneration", "Normal")) + 
  scale_fill_manual(values = c("#77284e", "#ffffff")) +
  theme_classic() + theme(
              panel.border = element_blank(),
              panel.background = element_blank(),
              plot.title = element_text(size = 14, family = "Tahoma", face = "bold"),
              text = element_text(family = "Tahoma"),
              axis.title = element_text(face = "bold"),
              axis.text.x = element_text(colour = "black", size = 11),
              axis.text.y = element_text(colour = "black", size = 9),
              axis.line = element_line(size = 0.5, colour = "black"),
              legend.position = "none")
```

```{r, fig.align='center'}
#Plot of disease state vs control that is stratified by sex:
AMD_Epigenetic_AgeSkinBlood$Sex <- factor(AMD_Epigenetic_AgeSkinBlood$Sex)
ggplot(data = AMD_Epigenetic_AgeSkinBlood, 
       aes(x = Sample_Group, y = AgeAccelSkinBlood, fill = Sex)) + 
  geom_boxplot(position = position_dodge(0.7), width = 0.5, outlier.shape = NA) +
  geom_jitter(aes(fill = Sex), size = 1, shape = 21, alpha = 0.7, 
              position = position_jitterdodge(dodge.width = 0.75, jitter.width = 0.3)) + 
  xlab("Disease State") + ylab("Skin & Blood Age Acceleration Residual") + 
  scale_x_discrete(breaks = c("age-related macular degeneration","normal"), 
                   labels = c("AMD", "Normal")) + 
  scale_fill_manual(values = c("#990000", "#2c7dab")) +
  theme_classic() + theme(
              panel.border = element_blank(),
              panel.background = element_blank(),
              plot.title = element_text(size = 14, family = "Tahoma", face = "bold"),
              text = element_text(family = "Tahoma"),
              axis.title = element_text(face = "bold"),
              axis.text.x = element_text(colour = "black", size = 11),
              axis.text.y = element_text(colour = "black", size = 9),
              axis.line = element_line(size = 0.5, colour = "black"))
```

```{r}
#Determine statistical significance between disease state vs control with ANOVA.
summary(lm(AgeAccelSkinBlood ~ Sample_Group + Sex + Sex*Sample_Group, data = AMD_Epigenetic_AgeSkinBlood))
summary(aov(AgeAccelSkinBlood ~ Sample_Group + Sex + Sex*Sample_Group, data = AMD_Epigenetic_AgeSkinBlood))
```


###Step 9: Prepare data for Zhang clock.

```{r}
AMD_Epigenetic_Age_Zhang <- AMD_samplesheet[, c("Sample_Name", "Sample_Group", "Tissue", "Sex", "Age")]

AMD_betas.Zhang <- getBeta(AMD_MSet.noob)
```


###Step 10: Run Zhang clock.

Adapted from predictor code for [Zhang clock](https://genomemedicine.biomedcentral.com/articles/10.1186/s13073-019-0667-1#Sec12).

This script is used to do age prediction based on Illumina 450K DNA methylation data. Coefficients of the predictor are based on 13,566 training samples. Two age predictors based on different methods (Elastic Net and BLUP) are developed based on 514 DNAm sites.

```{r}
#Function changes missing value to mean value across all individuals for each probe. 
addna <- function(methy){
         methy[is.na(methy)]<-mean(methy,na.rm=T)
         return(methy)
}

#Load beta matrix and check format.
if(nrow(AMD_betas.Zhang) > ncol(AMD_betas.Zhang)){
        AMD_betas.Zhang <- t(AMD_betas.Zhang)
}

#Replace any NA with mean value for each probe.
dataNona <- apply(AMD_betas.Zhang, 2, function(x) addna(x)) 

#Standardise beta values within each individual by removing the mean and dividing by standard deviation for each individual. (Probe * IND).
dataNona.norm <- apply(dataNona, 1, scale)
rownames(dataNona.norm) <- colnames(dataNona)

#Get the ElasticNet predictor coefficient of each probe.
encoef <- read.table("~/KoborLab/kobor_space/kendrix/macular_degeneration/Zhang_Age_Predictor/en.coef", 
                     stringsAsFactor = FALSE, header = TRUE)
en_int <- encoef[1,2]
encoef <- encoef[-1,]
rownames(encoef) <- encoef$probe

#Get the BLUP coefficient of each probe.
blupcoef <- read.table("~/KoborLab/kobor_space/kendrix/macular_degeneration/Zhang_Age_Predictor/blup.coef",
                       stringsAsFactor = FALSE, header = TRUE)
blup_int <- blupcoef[1,2]
blupcoef <- blupcoef[-1,]
rownames(blupcoef) <- blupcoef$probe

#Get common probes between predictors and data.
encomm <- intersect(rownames(encoef), rownames(dataNona.norm))
blupcomm <- intersect(rownames(blupcoef), rownames(dataNona.norm))

#Check for missing probes.
endiff <- nrow(encoef) - length(encomm)
blupdiff <- nrow(blupcoef) - length(blupcomm)

print(paste0 (endiff, " probe(s) in Elastic Net predictor is(are) not in the data"))
print(paste0 (blupdiff, " probe(s) in BLUP predictor is(are) not in the data"))
print("BLUP can perform better if the number of missing probes is too large!")

#Extract common probes and perform age prediction.
encoef <- encoef[encomm,]
blupcoef <- blupcoef[blupcomm,]
ElasticNetPredAge <- encoef$coef%*%dataNona.norm[encomm,] + en_int
BLUPPredAge <- blupcoef$coef%*%dataNona.norm[blupcomm,] + blup_int

#Add predicted results to metadata. 
ElasticNetPredAge <- ElasticNetPredAge[, AMD_Epigenetic_Age_Zhang$Sample_Name]
AMD_Epigenetic_Age_Zhang$ElasticNetPredAge <- as.double(ElasticNetPredAge)
AMD_Epigenetic_Age_Zhang$ElasticNetAgeAccelResidual <- lm(ElasticNetPredAge ~ Age, 
                                                          data = AMD_Epigenetic_Age_Zhang)$residuals

BLUPPredAge <- BLUPPredAge[, AMD_Epigenetic_Age_Zhang$Sample_Name]
AMD_Epigenetic_Age_Zhang$BLUPPredAge <- as.double(BLUPPredAge)
AMD_Epigenetic_Age_Zhang$BLUPAgeAccelResidual <- lm(BLUPPredAge ~ Age, 
                                                    data = AMD_Epigenetic_Age_Zhang)$residuals
```


###Step 11: Zhang clock - ElasticNet method.

```{r, fig.align='center'}
#Create function to plot linear regression.
ggplotRegression <- function (fit) {

require(ggplot2)

ggplot(fit$model, aes_string(x = names(fit$model)[2], y = names(fit$model)[1])) + 
  geom_point(aes(colour = AMD_Epigenetic_Age_Zhang$Sex, shape = AMD_Epigenetic_Age_Zhang$Sample_Group)) +
  stat_smooth(method = "lm", col = "red") 
}

#Regression plot of Zhang clock predicted DNAmAge against reported age:
AMD_ENZhang_plot <- lm(ElasticNetPredAge ~ Age, data = AMD_Epigenetic_Age_Zhang)
ggplotRegression(AMD_ENZhang_plot) + labs(x = "Reported age", y = "Zhang predicted age", caption = "Comparing reported age and predicted age using Zhang epigenetic clock - ElasticNet method") + 
  scale_colour_manual(name = "Sex", values = c("#990000", "#2c7dab")) +
  scale_shape_manual(name = "Disease State", values = c(20, 23), labels = c("AMD", "Normal")) +
  stat_cor(method = "spearman") +
  theme_bw() + theme(panel.border = element_blank(), 
                     panel.grid.major = element_blank(), 
                     panel.grid.minor = element_blank(), 
                     axis.line = element_line(colour = "black"), 
                     axis.text = element_text(), 
                     axis.title = element_text(size = 8), 
                     plot.caption = element_text(hjust = 0.5, size = rel(1)))
```

```{r, fig.align='center'}
#Plot of overall disease state vs control:
AMD_Epigenetic_Age_Zhang$Sample_Group <- factor(AMD_Epigenetic_Age_Zhang$Sample_Group)
ggplot(data = AMD_Epigenetic_Age_Zhang, 
       aes(x = Sample_Group, y = ElasticNetAgeAccelResidual, fill = Sample_Group)) +
  geom_boxplot(position = position_dodge(0.7), width = 0.5, outlier.shape = NA) +
  geom_jitter(aes(fill = Sample_Group), size = 2, shape = 21, alpha = 0.7, 
              position = position_jitterdodge(dodge.width = 0.75, jitter.width = 0.3)) + 
  xlab("Disease State") + ylab("Zhang Acceleration Residual (ElasticNet)") + 
  scale_x_discrete(breaks = c("age-related macular degeneration","normal"), 
                   labels = c("Age-Related Macular Degeneration", "Normal")) + 
  scale_fill_manual(values = c("#77284e", "#ffffff")) +
  theme_classic() + theme(
              panel.border = element_blank(),
              panel.background = element_blank(),
              plot.title = element_text(size = 14, family = "Tahoma", face = "bold"),
              text = element_text(family = "Tahoma"),
              axis.title = element_text(face = "bold"),
              axis.text.x = element_text(colour = "black", size = 11),
              axis.text.y = element_text(colour = "black", size = 9),
              axis.line = element_line(size = 0.5, colour = "black"),
              legend.position = "none")
```

```{r, fig.align='center'}
#Plot of disease state vs control that is stratified by sex:
AMD_Epigenetic_Age_Zhang$Sex <- factor(AMD_Epigenetic_Age_Zhang$Sex)
ggplot(data = AMD_Epigenetic_Age_Zhang, 
       aes(x = Sample_Group, y = ElasticNetAgeAccelResidual, fill = Sex)) + 
  geom_boxplot(position = position_dodge(0.7), width = 0.5, outlier.shape = NA) +
  geom_jitter(aes(fill = Sex), size = 1, shape = 21, alpha = 0.7, 
              position = position_jitterdodge(dodge.width = 0.75, jitter.width = 0.3)) + 
  xlab("Disease State") + ylab("Zhang Acceleration Residual (ElasticNet)") + 
  scale_x_discrete(breaks = c("age-related macular degeneration","normal"), 
                   labels = c("AMD", "Normal")) + 
  scale_fill_manual(values = c("#990000", "#2c7dab")) +
  theme_classic() + theme(
              panel.border = element_blank(),
              panel.background = element_blank(),
              plot.title = element_text(size = 14, family = "Tahoma", face = "bold"),
              text = element_text(family = "Tahoma"),
              axis.title = element_text(face = "bold"),
              axis.text.x = element_text(colour = "black", size = 11),
              axis.text.y = element_text(colour = "black", size = 9),
              axis.line = element_line(size = 0.5, colour = "black"))
```

```{r}
#Determine statistical significance between disease state vs control with ANOVA.
summary(lm(ElasticNetAgeAccelResidual ~ Sample_Group + Sex + Sex*Sample_Group, data = AMD_Epigenetic_Age_Zhang))
summary(aov(ElasticNetAgeAccelResidual ~ Sample_Group + Sex + Sex*Sample_Group, data = AMD_Epigenetic_Age_Zhang))
```


###Step 12: Zhang clock - BLUP method.

```{r, fig.align='center'}
#Create function to plot linear regression.
ggplotRegression <- function (fit) {

require(ggplot2)

ggplot(fit$model, aes_string(x = names(fit$model)[2], y = names(fit$model)[1])) + 
  geom_point(aes(colour = AMD_Epigenetic_Age_Zhang$Sex, shape = AMD_Epigenetic_Age_Zhang$Sample_Group)) +
  stat_smooth(method = "lm", col = "red") 
}

#Regression plot of Zhang clock predicted DNAmAge against reported age:
AMD_BLUPZhang_plot <- lm(BLUPPredAge ~ Age, data = AMD_Epigenetic_Age_Zhang)
ggplotRegression(AMD_BLUPZhang_plot) + labs(x = "Reported age", y = "Zhang predicted age", caption = "Comparing reported age and predicted age using Zhang epigenetic clock - BLUP method") + 
  scale_colour_manual(name = "Sex", values = c("#990000", "#2c7dab")) +
  scale_shape_manual(name = "Disease State", values = c(20, 23), labels = c("AMD", "Normal")) +
  stat_cor(method = "spearman") +
  theme_bw() + theme(panel.border = element_blank(), 
                     panel.grid.major = element_blank(), 
                     panel.grid.minor = element_blank(), 
                     axis.line = element_line(colour = "black"), 
                     axis.text = element_text(), 
                     axis.title = element_text(size = 8), 
                     plot.caption = element_text(hjust = 0.5, size = rel(1)))
```

```{r, fig.align='center'}
#Plot of overall disease state vs control:
AMD_Epigenetic_Age_Zhang$Sample_Group <- factor(AMD_Epigenetic_Age_Zhang$Sample_Group)
ggplot(data = AMD_Epigenetic_Age_Zhang, 
       aes(x = Sample_Group, y = BLUPAgeAccelResidual, fill = Sample_Group)) +
  geom_boxplot(position = position_dodge(0.7), width = 0.5, outlier.shape = NA) +
  geom_jitter(aes(fill = Sample_Group), size = 2, shape = 21, alpha = 0.7, 
              position = position_jitterdodge(dodge.width = 0.75, jitter.width = 0.3)) + 
  xlab("Disease State") + ylab("Zhang Acceleration Residual (BLUP)") + 
  scale_x_discrete(breaks = c("age-related macular degeneration","normal"), 
                   labels = c("Age-Related Macular Degeneration", "Normal")) + 
  scale_fill_manual(values = c("#77284e", "#ffffff")) +
  theme_classic() + theme(
              panel.border = element_blank(),
              panel.background = element_blank(),
              plot.title = element_text(size = 14, family = "Tahoma", face = "bold"),
              text = element_text(family = "Tahoma"),
              axis.title = element_text(face = "bold"),
              axis.text.x = element_text(colour = "black", size = 11),
              axis.text.y = element_text(colour = "black", size = 9),
              axis.line = element_line(size = 0.5, colour = "black"),
              legend.position = "none")
```

```{r, fig.align='center'}
#Plot of disease state vs control that is stratified by sex:
AMD_Epigenetic_Age_Zhang$Sex <- factor(AMD_Epigenetic_Age_Zhang$Sex)
ggplot(data = AMD_Epigenetic_Age_Zhang, 
       aes(x = Sample_Group, y = BLUPAgeAccelResidual, fill = Sex)) + 
  geom_boxplot(position = position_dodge(0.7), width = 0.5, outlier.shape = NA) +
  geom_jitter(aes(fill = Sex), size = 1, shape = 21, alpha = 0.7, 
              position = position_jitterdodge(dodge.width = 0.75, jitter.width = 0.3)) + 
  xlab("Disease State") + ylab("Zhang Acceleration Residual (BLUP)") + 
  scale_x_discrete(breaks = c("age-related macular degeneration","normal"), 
                   labels = c("AMD", "Normal")) + 
  scale_fill_manual(values = c("#990000", "#2c7dab")) +
  theme_classic() + theme(
              panel.border = element_blank(),
              panel.background = element_blank(),
              plot.title = element_text(size = 14, family = "Tahoma", face = "bold"),
              text = element_text(family = "Tahoma"),
              axis.title = element_text(face = "bold"),
              axis.text.x = element_text(colour = "black", size = 11),
              axis.text.y = element_text(colour = "black", size = 9),
              axis.line = element_line(size = 0.5, colour = "black"))
```

```{r}
#Determine statistical significance between disease state vs control with ANOVA.
summary(lm(BLUPAgeAccelResidual ~ Sample_Group + Sex + Sex*Sample_Group, data = AMD_Epigenetic_Age_Zhang))
summary(aov(BLUPAgeAccelResidual ~ Sample_Group + Sex + Sex*Sample_Group, data = AMD_Epigenetic_Age_Zhang))
```


###Step 13: Run DNAmCortical clock.

This script is used to do age prediction based on Illumina 450K DNA methylation data. Coefficients of the predictor are based on 1,397 cortical tissues (Age range: 1 - 104 years old). [Shireby et al.](https://www.biorxiv.org/content/10.1101/2020.04.27.063719v1.full) identified 347 DNAm sites that, in combination optimally predict age in the human cortex using elastic net regression. 

```{r}
#Get beta matrix.
AMD_betas.Cortical <- getBeta(AMD_MSet.noob)

#Check if sample name order match in pData and beta matrix.
identical(rownames(AMD_pData), colnames(AMD_betas.Cortical)) #TRUE.

#Run DNAmCortical clock.
source("~/KoborLab/kobor_space/kendrix/macular_degeneration/CorticalClock/CorticalClock.r")
setwd("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/")

CorticalClock(betas = AMD_betas.Cortical, pheno = AMD_pData, 
              dir = "~/KoborLab/kobor_space/kendrix/macular_degeneration/CorticalClock/", IDcol = "Sample_Name", 
              Agecol = "Age")

#Add predicted values to the cortical pData.
AMD_Epigenetic_Age_Cortical <- AMD_samplesheet[, c("Sample_Name", "Sample_Group", "Tissue", "Sex", "Age")]
DNAmCortical <- read.csv("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/CorticalPred.csv", header = TRUE)

identical(AMD_Epigenetic_Age_Cortical$Sample_Name, DNAmCortical$ID) #TRUE.
AMD_Epigenetic_Age_Cortical$DNAmCorticalPredAge <- DNAmCortical$brainpred
AMD_Epigenetic_Age_Cortical$DNAmCorticalAgeAccelResidual <- lm(DNAmCorticalPredAge ~ Age, 
                                                          data = AMD_Epigenetic_Age_Cortical)$residuals
```


###Step 14: DNAmCortical clock.

```{r, fig.align='center'}
#Create function to plot linear regression.
ggplotRegression <- function (fit) {

require(ggplot2)

ggplot(fit$model, aes_string(x = names(fit$model)[2], y = names(fit$model)[1])) + 
  geom_point(aes(colour = AMD_Epigenetic_Age_Cortical$Sex, shape = AMD_Epigenetic_Age_Cortical$Sample_Group)) +
  stat_smooth(method = "lm", col = "red") 
}

#Regression plot of Zhang clock predicted DNAmAge against reported age:
AMD_Cortical_plot <- lm(DNAmCorticalPredAge ~ Age, data = AMD_Epigenetic_Age_Cortical)
ggplotRegression(AMD_Cortical_plot) + labs(x = "Reported age", y = "DNAmCortical predicted age", caption = "Comparing reported age and predicted age using DNAmCortical epigenetic clock") + 
  scale_colour_manual(name = "Sex", values = c("#990000", "#2c7dab")) +
  scale_shape_manual(name = "Disease State", values = c(20, 23), labels = c("AMD", "Normal")) +
  stat_cor(method = "spearman") +
  theme_bw() + theme(panel.border = element_blank(), 
                     panel.grid.major = element_blank(), 
                     panel.grid.minor = element_blank(), 
                     axis.line = element_line(colour = "black"), 
                     axis.text = element_text(), 
                     axis.title = element_text(size = 8), 
                     plot.caption = element_text(hjust = 0.5, size = rel(1)))
```

```{r, fig.align='center'}
#Plot of overall disease state vs control:
AMD_Epigenetic_Age_Cortical$Sample_Group <- factor(AMD_Epigenetic_Age_Cortical$Sample_Group)
ggplot(data = AMD_Epigenetic_Age_Cortical, 
       aes(x = Sample_Group, y = DNAmCorticalAgeAccelResidual, fill = Sample_Group)) +
  geom_boxplot(position = position_dodge(0.7), width = 0.5, outlier.shape = NA) +
  geom_jitter(aes(fill = Sample_Group), size = 2, shape = 21, alpha = 0.7, 
              position = position_jitterdodge(dodge.width = 0.75, jitter.width = 0.3)) + 
  xlab("Disease State") + ylab("DNAmCortical Acceleration Residual") + 
  scale_x_discrete(breaks = c("age-related macular degeneration","normal"), 
                   labels = c("Age-Related Macular Degeneration", "Normal")) + 
  scale_fill_manual(values = c("#77284e", "#ffffff")) +
  theme_classic() + theme(
              panel.border = element_blank(),
              panel.background = element_blank(),
              plot.title = element_text(size = 14, family = "Tahoma", face = "bold"),
              text = element_text(family = "Tahoma"),
              axis.title = element_text(face = "bold"),
              axis.text.x = element_text(colour = "black", size = 11),
              axis.text.y = element_text(colour = "black", size = 9),
              axis.line = element_line(size = 0.5, colour = "black"),
              legend.position = "none")
```

```{r, fig.align='center'}
#Plot of disease state vs control that is stratified by sex:
AMD_Epigenetic_Age_Cortical$Sex <- factor(AMD_Epigenetic_Age_Cortical$Sex)
ggplot(data = AMD_Epigenetic_Age_Cortical, 
       aes(x = Sample_Group, y = DNAmCorticalAgeAccelResidual, fill = Sex)) + 
  geom_boxplot(position = position_dodge(0.7), width = 0.5, outlier.shape = NA) +
  geom_jitter(aes(fill = Sex), size = 1, shape = 21, alpha = 0.7, 
              position = position_jitterdodge(dodge.width = 0.75, jitter.width = 0.3)) + 
  xlab("Disease State") + ylab("DNAmCortical Acceleration Residual") + 
  scale_x_discrete(breaks = c("age-related macular degeneration","normal"), 
                   labels = c("AMD", "Normal")) + 
  scale_fill_manual(values = c("#990000", "#2c7dab")) +
  theme_classic() + theme(
              panel.border = element_blank(),
              panel.background = element_blank(),
              plot.title = element_text(size = 14, family = "Tahoma", face = "bold"),
              text = element_text(family = "Tahoma"),
              axis.title = element_text(face = "bold"),
              axis.text.x = element_text(colour = "black", size = 11),
              axis.text.y = element_text(colour = "black", size = 9),
              axis.line = element_line(size = 0.5, colour = "black"))
```

```{r}
#Determine statistical significance between disease state vs control with ANOVA.
summary(lm(DNAmCorticalAgeAccelResidual ~ Sample_Group + Sex + Sex*Sample_Group, data = AMD_Epigenetic_Age_Cortical))
summary(aov(DNAmCorticalAgeAccelResidual ~ Sample_Group + Sex + Sex*Sample_Group, data = AMD_Epigenetic_Age_Cortical))
```


###Step 15: Prepare data for PedBE clock.

```{r}
AMD_Epigenetic_Age_PedBE <- AMD_samplesheet[, c("Sample_Name", "Sample_Group", "Tissue", "Sex", "Age")]

AMD_betas.PedBE <- getBeta(AMD_MSet.noob)
```


###Step 16: Run PedBE clock.

Sourced and adapted from "~/KoborLab/kobor_space/shared_coding_resource/Ped_Age_Predictor_McEwen/Age_Pred_McEwen_NG.R".

```{r}
PedAge_McEwen_NG <- function(dat0){

#call required libraries  
  require(WGCNA)
  require(sqldf)
  require(impute)
  require(flashClust)
  require(dynamicTreeCut)
  require(RPMM)

source("~/KoborLab/kobor_space/shared_coding_resource/Horvath_Age_Prediction/NORMALIZATION.R")
datClock <- read.csv("~/KoborLab/kobor_space/shared_coding_resource/Ped_Age_Predictor_McEwen/datcoefInteresting94.csv", stringsAsFactors = F)  

# Impute missing data 
if(sum(is.na(dat0)) > 0) {dat0=data.frame(t(impute.knn(as.matrix(t(dat0)))$data))}

# How many probes are missing from the clock
print(paste("You have", length(rownames(dat0)[rownames(dat0) %in% datClock$ID[2:nrow(datClock)]]), "out of", length(datClock$ID[2:nrow(datClock)]), "probes needed for the age clock. Missing", length(datClock$ID[2:nrow(datClock)]) - length(rownames(dat0)[rownames(dat0) %in% datClock$ID[2:nrow(datClock)]]), "altogether."))
print(paste("Resulting in", round(100-100*(length(rownames(dat0)[rownames(dat0) %in% datClock$ID[2:nrow(datClock)]])/length(datClock$ID[2:nrow(datClock)])), 0),"% missingness. Data will be imputed using training data."))

# Add probe names as the first column
dat0 <- as.data.frame(dat0)
dat0$ProbeID <- rownames(dat0)
dat0 <- dat0[, c(ncol(dat0), 1:(ncol(dat0)-1))]
nSamples <- dim(dat0)[[2]]-1
nProbes <- dim(dat0)[[1]]  

#Normalize data
dat1 <- dat0[,-1]
gold.mean <- as.numeric(apply(dat1, 1, median, na.rm = TRUE))
datMethUsed <- t(dat1)
datMethUsedNormalized <- BMIQcalibration(datM = datMethUsed, goldstandard.beta = gold.mean, plots = FALSE)
datM <- t(datMethUsedNormalized)
datM <- as.data.frame(datM)
datM$ProbeID <- rownames(datM)
datM <- datM[, c(ncol(datM), 1:(ncol(datM)-1))]
datMt <- t(datM[,-1])
colnames(datMt) <- as.character(datM[,1])
anti.trafo <- function(x,adult.age=20) {ifelse(x<0, (1+adult.age)*exp(x)-1, (1+adult.age)*x+adult.age)}
selectCpGsClock <- is.element(dimnames(datMt)[[2]], as.character(datClock[,1][-1]))
datMethClock0 <- data.frame(datMt[,selectCpGsClock])
datMethClock <- data.frame(datMethClock0[as.character(datClock[,1][-1])])
datMethClock$DNAmAgeBuccal <- as.numeric(anti.trafo(datClock[1,2]+as.numeric(as.matrix(datMethClock)%*%as.numeric(datClock[,2][-1]))))
datout <- data.frame(SampleID <- rownames(datMethClock), DNAmAge <- datMethClock$DNAmAgeBuccal)
}
```

```{r}
dim(AMD_betas.PedBE) #485512 rows.

#Remove rows with more than 50% NA
AMD_betas.PedBE <- AMD_betas.PedBE[which(rowMeans(!is.na(AMD_betas.PedBE)) > 0.5), ]

#Run PedBE clock.
PedBE_DNAmAge <- PedAge_McEwen_NG(AMD_betas.PedBE)
AMD_Epigenetic_Age_PedBE <- cbind(AMD_Epigenetic_Age_PedBE, PedBE_DNAmAge$DNAmAge....datMethClock.DNAmAgeBuccal)
colnames(AMD_Epigenetic_Age_PedBE)[6] <- "DNAmAgePedBE"

AMD_Epigenetic_Age_PedBE$DNAmPedBEAgeAccelResidual <- lm(DNAmAgePedBE ~ Age, 
                                                          data = AMD_Epigenetic_Age_PedBE)$residuals
```


###Step 17: PedBE clock.

```{r, fig.align='center'}
#Create function to plot linear regression.
ggplotRegression <- function (fit) {

require(ggplot2)

ggplot(fit$model, aes_string(x = names(fit$model)[2], y = names(fit$model)[1])) + 
  geom_point(aes(colour = AMD_Epigenetic_Age_PedBE$Sex, shape = AMD_Epigenetic_Age_PedBE$Sample_Group)) +
  stat_smooth(method = "lm", col = "red") 
}

#Regression plot of Zhang clock predicted DNAmAge against reported age:
AMD_PedBE_plot <- lm(DNAmAgePedBE ~ Age, data = AMD_Epigenetic_Age_PedBE)
ggplotRegression(AMD_PedBE_plot) + labs(x = "Reported age", y = "DNAmPedBE predicted age", caption = "Comparing reported age and predicted age using PedBE epigenetic clock") + 
  scale_colour_manual(name = "Sex", values = c("#990000", "#2c7dab")) +
  scale_shape_manual(name = "Disease State", values = c(20, 23), labels = c("AMD", "Normal")) +
  stat_cor(method = "spearman") +
  theme_bw() + theme(panel.border = element_blank(), 
                     panel.grid.major = element_blank(), 
                     panel.grid.minor = element_blank(), 
                     axis.line = element_line(colour = "black"), 
                     axis.text = element_text(), 
                     axis.title = element_text(size = 8), 
                     plot.caption = element_text(hjust = 0.5, size = rel(1)))
```

```{r, fig.align='center'}
#Plot of overall disease state vs control:
AMD_Epigenetic_Age_PedBE$Sample_Group <- factor(AMD_Epigenetic_Age_PedBE$Sample_Group)
ggplot(data = AMD_Epigenetic_Age_PedBE, 
       aes(x = Sample_Group, y = DNAmPedBEAgeAccelResidual, fill = Sample_Group)) +
  geom_boxplot(position = position_dodge(0.7), width = 0.5, outlier.shape = NA) +
  geom_jitter(aes(fill = Sample_Group), size = 2, shape = 21, alpha = 0.7, 
              position = position_jitterdodge(dodge.width = 0.75, jitter.width = 0.3)) + 
  xlab("Disease State") + ylab("DNAmPedBE Acceleration Residual") + 
  scale_x_discrete(breaks = c("age-related macular degeneration","normal"), 
                   labels = c("Age-Related Macular Degeneration", "Normal")) + 
  scale_fill_manual(values = c("#77284e", "#ffffff")) +
  theme_classic() + theme(
              panel.border = element_blank(),
              panel.background = element_blank(),
              plot.title = element_text(size = 14, family = "Tahoma", face = "bold"),
              text = element_text(family = "Tahoma"),
              axis.title = element_text(face = "bold"),
              axis.text.x = element_text(colour = "black", size = 11),
              axis.text.y = element_text(colour = "black", size = 9),
              axis.line = element_line(size = 0.5, colour = "black"),
              legend.position = "none")
```

```{r, fig.align='center'}
#Plot of disease state vs control that is stratified by sex:
AMD_Epigenetic_Age_PedBE$Sex <- factor(AMD_Epigenetic_Age_PedBE$Sex)
ggplot(data = AMD_Epigenetic_Age_PedBE, 
       aes(x = Sample_Group, y = DNAmPedBEAgeAccelResidual, fill = Sex)) + 
  geom_boxplot(position = position_dodge(0.7), width = 0.5, outlier.shape = NA) +
  geom_jitter(aes(fill = Sex), size = 1, shape = 21, alpha = 0.7, 
              position = position_jitterdodge(dodge.width = 0.75, jitter.width = 0.3)) + 
  xlab("Disease State") + ylab("DNAmPedBE Acceleration Residual") + 
  scale_x_discrete(breaks = c("age-related macular degeneration","normal"), 
                   labels = c("AMD", "Normal")) + 
  scale_fill_manual(values = c("#990000", "#2c7dab")) +
  theme_classic() + theme(
              panel.border = element_blank(),
              panel.background = element_blank(),
              plot.title = element_text(size = 14, family = "Tahoma", face = "bold"),
              text = element_text(family = "Tahoma"),
              axis.title = element_text(face = "bold"),
              axis.text.x = element_text(colour = "black", size = 11),
              axis.text.y = element_text(colour = "black", size = 9),
              axis.line = element_line(size = 0.5, colour = "black"))
```

```{r}
#Determine statistical significance between disease state vs control with ANOVA.
summary(lm(DNAmPedBEAgeAccelResidual ~ Sample_Group + Sex + Sex*Sample_Group, data = AMD_Epigenetic_Age_PedBE))
summary(aov(DNAmPedBEAgeAccelResidual ~ Sample_Group + Sex + Sex*Sample_Group, data = AMD_Epigenetic_Age_PedBE))
```


###Step 18: GrimAge clock.

```{r, fig.align='center'}
#Subset relevant epigenetic age variables. 
AMD_Epigenetic_Age_Grim <- AMD_pData[, c("Sample_Name", "Sample_Group", "Array", "Slide", "Sex", "predictedGender", "Tissue", "predictedTissue", "Age", "DNAmGrimAge", "AgeAccelGrim")] 

#Create function to plot linear regression.
ggplotRegression <- function (fit) {

require(ggplot2)

ggplot(fit$model, aes_string(x = names(fit$model)[2], y = names(fit$model)[1])) + 
  geom_point(aes(colour = AMD_Epigenetic_Age_Grim$Sex, shape = AMD_Epigenetic_Age_Grim$Sample_Group, size = 1)) +
  guides(size = FALSE) +
  stat_smooth(method = "lm", col = "red") 
}

#Regression plot of Grim predicted DNAmAge against reported age:
AMD_Grim_plot <- lm(DNAmGrimAge ~ Age, data = AMD_Epigenetic_Age_Grim)
ggplotRegression(AMD_Grim_plot) + labs(x = "Reported age", y = "DNAmGrimAge predicted age", caption = "Comparing reported age and predicted age using GrimAge epigenetic clock") + 
  scale_colour_manual(name = "Sex", values = c("#990000", "#2c7dab"), labels = c("Female", "Male")) +
  scale_shape_manual(name = "Disease State", values = c(20, 23), labels = c("AMD", "Normal")) +
  stat_cor(method = "spearman") +
  theme_bw() + theme(panel.border = element_blank(), 
                     panel.grid.major = element_blank(), 
                     panel.grid.minor = element_blank(), 
                     axis.line = element_line(colour = "black"), 
                     axis.text = element_text(), 
                     axis.title = element_text(size = 8), 
                     plot.caption = element_text(hjust = 0.5, size = rel(1)))
```

```{r, fig.align='center'}
#Plot of overall disease state vs control:
AMD_Epigenetic_Age_Grim$Sample_Group <- factor(AMD_Epigenetic_Age_Grim$Sample_Group)
ggplot(data = AMD_Epigenetic_Age_Grim, 
       aes(x = Sample_Group, y = AgeAccelGrim, fill = Sample_Group)) +
  geom_boxplot(position = position_dodge(0.7), width = 0.5, outlier.shape = NA) +
  geom_jitter(aes(fill = Sample_Group), size = 2, shape = 21, alpha = 0.7, 
              position = position_jitterdodge(dodge.width = 0.75, jitter.width = 0.3)) + 
  xlab("Disease State") + ylab("DNAmGrimAge Acceleration Residual") + 
  scale_x_discrete(breaks = c("age-related macular degeneration","normal"), 
                   labels = c("Age-Related Macular Degeneration", "Normal")) + 
  scale_fill_manual(values = c("#77284e", "#ffffff")) +
  theme_classic() + theme(
              panel.border = element_blank(),
              panel.background = element_blank(),
              plot.title = element_text(size = 14, family = "Tahoma", face = "bold"),
              text = element_text(family = "Tahoma"),
              axis.title = element_text(face = "bold"),
              axis.text.x = element_text(colour = "black", size = 11),
              axis.text.y = element_text(colour = "black", size = 9),
              axis.line = element_line(size = 0.5, colour = "black"),
              legend.position = "none")
```

```{r, fig.align='center'}
#Plot of disease state vs control that is stratified by sex:
AMD_Epigenetic_Age_Grim$Sex <- factor(AMD_Epigenetic_Age_Grim$Sex)
ggplot(data = AMD_Epigenetic_Age_Grim, 
       aes(x = Sample_Group, y = AgeAccelGrim, fill = Sex)) + 
  geom_boxplot(position = position_dodge(0.7), width = 0.5, outlier.shape = NA) +
  geom_jitter(aes(fill = Sex), size = 2, shape = 21, alpha = 0.7, 
              position = position_jitterdodge(dodge.width = 0.75, jitter.width = 0.3)) + 
  xlab("Disease State") + ylab("DNAmGrimAge Acceleration Residual") + 
  scale_x_discrete(breaks = c("age-related macular degeneration","normal"), 
                   labels = c("AMD", "Normal")) + 
  scale_fill_manual(values = c("#990000", "#2c7dab")) +
  theme_classic() + theme(
              panel.border = element_blank(),
              panel.background = element_blank(),
              plot.title = element_text(size = 14, family = "Tahoma", face = "bold"),
              text = element_text(family = "Tahoma"),
              axis.title = element_text(face = "bold"),
              axis.text.x = element_text(colour = "black", size = 11),
              axis.text.y = element_text(colour = "black", size = 9),
              axis.line = element_line(size = 0.5, colour = "black"))
```

```{r}
#Determine statistical significance between disease state vs control with ANOVA.
summary(lm(AgeAccelGrim ~ Sample_Group + Sex + Sex*Sample_Group, data = AMD_Epigenetic_Age_Grim))
summary(aov(AgeAccelGrim ~ Sample_Group + Sex + Sex*Sample_Group, data = AMD_Epigenetic_Age_Grim))
```


###Step 19: Calculate epigenetic age for Weidner clock.

The Weidner clock is developed from an initial 82 blood samples, which are then used to generate a multivariate model. Use the beta values at the following three CpG sites ((α) cg02228185; (β) cg25809905, and (γ) a CpG site upstream of cg17861230) to generate age-prediction, based on the equation from the model below. 

Predicted age (in years) = 38.0 - 26.4α - 23.7β + 164.7γ 

```{r}
AMD_Epigenetic_Age_Weidner <- AMD_samplesheet[, c("Sample_Name", "Sample_Group", "Tissue", "Sex", "Age")]
rownames(AMD_Epigenetic_Age_Weidner) <- AMD_Epigenetic_Age_Weidner$Sample_Name

AMD_betas.Weidner <- getBeta(AMD_MSet.noob)

#Subset the 3 CpG sites specified by the clock. 
Weidner_sites <- AMD_betas.Weidner[rownames(AMD_betas.Weidner) %in% c("cg02228185", "cg25809905", "cg17861230"),]
Weidner_sites <- as.data.frame(t(Weidner_sites))


#Check sample order. 
identical(rownames(AMD_Epigenetic_Age_Weidner), rownames(Weidner_sites)) #TRUE.

#Calculate Weidner epigenetic age.
AMD_Epigenetic_Age_Weidner$DNAmAgeWeidner <- 38.0 - 26.4*(Weidner_sites$cg02228185) - 23.7*(Weidner_sites$cg25809905) + 164.7*(Weidner_sites$cg17861230)

#Calculate Weidner age acceleration residual. 
AMD_Epigenetic_Age_Weidner$AgeAccelResidualWeidner <- lm(DNAmAgeWeidner ~ Age, data = AMD_Epigenetic_Age_Weidner)$residual
```


###Step 20: Weidner clock.

```{r, fig.align='center'}
#Create function to plot linear regression.
ggplotRegression <- function (fit) {

require(ggplot2)

ggplot(fit$model, aes_string(x = names(fit$model)[2], y = names(fit$model)[1])) + 
  geom_point(aes(colour = AMD_Epigenetic_Age_Weidner$Sex, shape = AMD_Epigenetic_Age_Weidner$Sample_Group)) +
  stat_smooth(method = "lm", col = "red") 
}

#Regression plot of Zhang clock predicted DNAmAge against reported age:
AMD_Weidner_plot <- lm(DNAmAgeWeidner ~ Age, data = AMD_Epigenetic_Age_Weidner)
ggplotRegression(AMD_Weidner_plot) + labs(x = "Reported age", y = "DNAmWeidner predicted age", caption = "Comparing reported age and predicted age using DNAmWeidner epigenetic clock") + 
  scale_colour_manual(name = "Sex", values = c("#990000", "#2c7dab")) +
  scale_shape_manual(name = "Disease State", values = c(20, 23), labels = c("AMD", "Normal")) +
  stat_cor(method = "spearman") +
  theme_bw() + theme(panel.border = element_blank(), 
                     panel.grid.major = element_blank(), 
                     panel.grid.minor = element_blank(), 
                     axis.line = element_line(colour = "black"), 
                     axis.text = element_text(), 
                     axis.title = element_text(size = 8), 
                     plot.caption = element_text(hjust = 0.5, size = rel(1)))
```

```{r, fig.align='center'}
#Plot of overall disease state vs control:
AMD_Epigenetic_Age_Weidner$Sample_Group <- factor(AMD_Epigenetic_Age_Weidner$Sample_Group)
ggplot(data = AMD_Epigenetic_Age_Weidner, 
       aes(x = Sample_Group, y = AgeAccelResidualWeidner, fill = Sample_Group)) +
  geom_boxplot(position = position_dodge(0.7), width = 0.5, outlier.shape = NA) +
  geom_jitter(aes(fill = Sample_Group), size = 2, shape = 21, alpha = 0.7, 
              position = position_jitterdodge(dodge.width = 0.75, jitter.width = 0.3)) + 
  xlab("Disease State") + ylab("DNAmWeidner Acceleration Residual") + 
  scale_x_discrete(breaks = c("age-related macular degeneration","normal"), 
                   labels = c("Age-Related Macular Degeneration", "Normal")) + 
  scale_fill_manual(values = c("#77284e", "#ffffff")) +
  theme_classic() + theme(
              panel.border = element_blank(),
              panel.background = element_blank(),
              plot.title = element_text(size = 14, family = "Tahoma", face = "bold"),
              text = element_text(family = "Tahoma"),
              axis.title = element_text(face = "bold"),
              axis.text.x = element_text(colour = "black", size = 11),
              axis.text.y = element_text(colour = "black", size = 9),
              axis.line = element_line(size = 0.5, colour = "black"),
              legend.position = "none")
```

```{r, fig.align='center'}
#Plot of disease state vs control that is stratified by sex:
AMD_Epigenetic_Age_Weidner$Sex <- factor(AMD_Epigenetic_Age_Weidner$Sex)
ggplot(data = AMD_Epigenetic_Age_Weidner, 
       aes(x = Sample_Group, y = AgeAccelResidualWeidner, fill = Sex)) + 
  geom_boxplot(position = position_dodge(0.7), width = 0.5, outlier.shape = NA) +
  geom_jitter(aes(fill = Sex), size = 1, shape = 21, alpha = 0.7, 
              position = position_jitterdodge(dodge.width = 0.75, jitter.width = 0.3)) + 
  xlab("Disease State") + ylab("DNAmWeidner Acceleration Residual") + 
  scale_x_discrete(breaks = c("age-related macular degeneration","normal"), 
                   labels = c("AMD", "Normal")) + 
  scale_fill_manual(values = c("#990000", "#2c7dab")) +
  theme_classic() + theme(
              panel.border = element_blank(),
              panel.background = element_blank(),
              plot.title = element_text(size = 14, family = "Tahoma", face = "bold"),
              text = element_text(family = "Tahoma"),
              axis.title = element_text(face = "bold"),
              axis.text.x = element_text(colour = "black", size = 11),
              axis.text.y = element_text(colour = "black", size = 9),
              axis.line = element_line(size = 0.5, colour = "black"))
```

```{r}
#Determine statistical significance between disease state vs control with ANOVA.
summary(lm(AgeAccelResidualWeidner ~ Sample_Group + Sex + Sex*Sample_Group, data = AMD_Epigenetic_Age_Weidner))
summary(aov(AgeAccelResidualWeidner ~ Sample_Group + Sex + Sex*Sample_Group, data = AMD_Epigenetic_Age_Weidner))
```


###Step 21: Summary of epigenetic clock outputs.

```{r}
#Combine all epigenetic clock outputs into a summary table. 
AMD_Epigenetic_All <- join_all(list(AMD_Epigenetic_Age_Horvath,
                                    AMD_Epigenetic_Age_Zhang,
                                    AMD_Epigenetic_Age_Hannum,
                                    AMD_Epigenetic_AgeSkinBlood,
                                    AMD_Epigenetic_Age_Cortical,
                                    AMD_Epigenetic_Age_PedBE,
                                    AMD_Epigenetic_Age_Weidner), 
                               by = "Sample_Name", type = "left")
AMD_Epigenetic_All <- AMD_Epigenetic_All[, !duplicated(colnames(AMD_Epigenetic_All))]

#Change column names to reflect outputs of various clocks. 
colnames(AMD_Epigenetic_All)[10:26] <- c("HorvathAge", "HorvathAgeAccelDiff", "HorvathAgeAccelResidual",
                                         "ZhangENAge", "ZhangENAgeAccelResidual", "ZhangBLUPAge", 
                                         "ZhangBLUPAgeAccelResidual", "HannumAge", "HannumAgeAccelResidual",
                                         "SkinBloodAge", "SkinBloodAgeAccelResidual", "CorticalAge", 
                                         "CorticalAgeAccelResidual", "PedBEAge", "PedBEAgeAccelResidual", 
                                         "WeidnerAge", "WeidnerAgeAccelResidual")
```


Plot all epigenetic clock outputs.

```{r, fig.align='center'}
#Melt wide form data to long form.
AMD_clocks.all <- AMD_Epigenetic_All[, c(1:10, 21, 17, 13, 15, 25, 19)]
AMD_clocks.melt <- melt(AMD_clocks.all)
colnames(AMD_clocks.melt)[c(9:10)] <- c("Epigenetic_clocks", "Age")

#Plot outputs together.
ggplot(data = AMD_clocks.melt, aes(x = Epigenetic_clocks, y = Age, fill = Epigenetic_clocks)) +
  geom_boxplot(position = position_dodge(0.7), width = 0.5, outlier.shape = NA) +
  xlab("\nEpigenetic Clocks Outputs") + ylab(element_blank()) +
  theme_classic() + theme(
              panel.border = element_blank(),
              panel.background = element_blank(),
              plot.title = element_text(size = 14, family = "Tahoma", face = "bold"),
              text = element_text(family = "Tahoma"),
              axis.title = element_text(face = "bold"),
              axis.text.x = element_text(colour = "black", size = 11),
              axis.text.y = element_text(colour = "black", size = 9),
              axis.line = element_line(size = 0.5, colour = "black"),
              legend.position = "none")

#Calculate RMSE.
rmse(AMD_clocks.all$Age, AMD_clocks.all$HorvathAge)
rmse(AMD_clocks.all$Age, AMD_clocks.all$HannumAge)
rmse(AMD_clocks.all$Age, AMD_clocks.all$CorticalAge)
rmse(AMD_clocks.all$Age, AMD_clocks.all$ZhangBLUPAge)
rmse(AMD_clocks.all$Age, AMD_clocks.all$ZhangENAge)
rmse(AMD_clocks.all$Age, AMD_clocks.all$SkinBloodAge)
rmse(AMD_clocks.all$Age, AMD_clocks.all$WeidnerAge)
```


Check correlation between predicted ages of various clocks.

```{r}
#Create correlation matrix.
AMD_clocks.cor <- AMD_clocks.all[, c(9:16)]
AMD_clocks.cor <- round(cor(AMD_clocks.cor), 2)

#Plot paired matrix.
library(psych)
pairs.panels(AMD_clocks.cor, 
             method = "pearson", # correlation method
             hist.col = "#00AFBB",
             density = FALSE,  # show density plots
             ellipses = FALSE # show correlation ellipses
             )
```


For Horvath's clock and Cortical Clock, bin the data to see progression of age acceleration.

```{r}
#Look at age and predicted age distributions. 
summary(AMD_Epigenetic_All$Age)
summary(AMD_Epigenetic_All$HorvathAge)
summary(AMD_Epigenetic_All$CorticalAge)

#Quickly visualise age distribution. 
hist(AMD_Epigenetic_All$Age, main = "Chronological Age Distribution", xlab = "Chronological Age")

#Horvath's clock:
#Bin epigenetic age acceleration difference according to chronological age.
#Define bucket intervals and name them.
tags <- c("Under 60", "60-69", "70-79", "Above 80")

#Place chronological ages into the buckets. Store groups as a new column.
v <- AMD_Epigenetic_All %>% select(Age, HorvathAgeAccelResidual) #pick the variable 
vgroup <- as_tibble(v) %>% mutate(tag = case_when(
    Age < 60 ~ tags[1],
    Age >= 60 & Age < 70 ~ tags[2],
    Age >= 70 & Age < 80 ~ tags[3],
    Age >= 80 ~ tags[4]
    ))
summary(vgroup)

#Factorise bins
vgroup$tag <- factor(vgroup$tag, levels = tags, ordered = FALSE)
summary(vgroup$tag)

#Visualise the binned data.
ggplot(data = vgroup, mapping = aes(x = tag, y = HorvathAgeAccelResidual)) + 
  geom_jitter(aes(color = 'blue'), alpha = 0.2) +
  geom_boxplot(fill = "#BB9D00", color = "black", alpha = 0.3) + 
  labs(x = "Chronological Age Deciles", y = "Horvath's Clock Age Acceleration") +
  guides(color = FALSE) +
  theme_minimal() 

#Cortical clock:
#Bin epigenetic age acceleration difference according to chronological age.
#Calculate cortical clock age acceleration difference.
AMD_Epigenetic_All$CorticalAgeAccelDiff <- AMD_Epigenetic_All$CorticalAge - AMD_Epigenetic_All$Age

#Define bucket intervals and name them.
tags <- c("Under 60", "60-69", "70-79", "Above 80")

#Place chronological ages into the buckets. Store groups as a new column.
v <- AMD_Epigenetic_All %>% select(Age, CorticalAgeAccelResidual) #pick the variable 
vgroup <- as_tibble(v) %>% mutate(tag = case_when(
    Age < 60 ~ tags[1],
    Age >= 60 & Age < 70 ~ tags[2],
    Age >= 70 & Age < 80 ~ tags[3],
    Age >= 80 ~ tags[4]
    ))
summary(vgroup)

#Factorise bins
vgroup$tag <- factor(vgroup$tag, levels = tags, ordered = FALSE)
summary(vgroup$tag)

#Visualise the binned data.
ggplot(data = vgroup, mapping = aes(x = tag, y = CorticalAgeAccelResidual)) + 
  geom_jitter(aes(color = 'blue'), alpha = 0.2) +
  geom_boxplot(fill = "#00B81F", color = "black", alpha = 0.3) + 
  labs(x = "Chronological Age Deciles", y = "Cortical Clock Age Acceleration") +
  guides(color = FALSE) +
  theme_minimal()
```


###Step 22: Age-associated CpG sites overlap.

```{r, eval=FALSE}
library(VennDiagram)
library(grid)

#Load epigenetic clock CpGs.
Epigenetic_clocks_CpGs <- read.csv("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/Epigenetic_clocks_CpGs.csv",
                                     header = TRUE)
Epigenetic_clocks_CpGs[Epigenetic_clocks_CpGs==""] <- NA

DNAmHorvath <- na.omit(as.character(Epigenetic_clocks_CpGs$DNAmHorvath))
DNAmHannum <- na.omit(as.character(Epigenetic_clocks_CpGs$DNAmHannum))
DNAmCortical <- na.omit(as.character(Epigenetic_clocks_CpGs$DNAmCortical))
DNAmSkinBlood <- na.omit(as.character(Epigenetic_clocks_CpGs$DNAmSkinBlood))
DNAmZhang <- na.omit(as.character(Epigenetic_clocks_CpGs$DNAmZhang))
DNAmWeidner <- na.omit(as.character(Epigenetic_clocks_CpGs$DNAmWeidner))

#Check similarity between DNAmWeidner CpGs with the other clocks.
Epigenetic_clocks_CpGs[Epigenetic_clocks_CpGs$DNAmHorvath %in% DNAmWeidner,]$DNAmHorvath
Epigenetic_clocks_CpGs[Epigenetic_clocks_CpGs$DNAmHannum %in% DNAmWeidner,]$DNAmHannum
Epigenetic_clocks_CpGs[Epigenetic_clocks_CpGs$DNAmCortical %in% DNAmWeidner,]$DNAmCortical
Epigenetic_clocks_CpGs[Epigenetic_clocks_CpGs$DNAmSkinBlood %in% DNAmWeidner,]$DNAmSkinBlood
Epigenetic_clocks_CpGs[Epigenetic_clocks_CpGs$DNAmZhang %in% DNAmWeidner,]$DNAmZhang
Epigenetic_clocks_CpGs[Epigenetic_clocks_CpGs$DNAmPhenoAge %in% DNAmWeidner,]$DNAmPhenoAge

#Make Venn diagram.
x <- list(DNAmHorvath, DNAmHannum, DNAmZhang, DNAmSkinBlood, DNAmCortical)

setwd("~/KoborLab/kobor_space/kendrix/macular_degeneration/plots/")
futile.logger::flog.threshold(futile.logger::ERROR, name = "VennDiagramLogger")
venn_cpg <- venn.diagram(x = x, 
             category.names = c("DNAmHorvath" , "DNAmHannum", "DNAmZhang", "DNAmSkinBlood", "DNAmCortical"), 
             filename = NULL,
             cat.cex = 0.8, cat.fontface = "bold", cat.default.pos = "inner", 
             cat.pos = c(10, 25, 55, 185, 190),
             cat.dist = c(0.08, 0.08, 0.08, 0.08, 0.08),
             scale = FALSE
             )
grid.newpage()
grid.draw(venn_cpg)
```


Find overlap between age-associated CpGs of Horvath's and Cortical clocks.

```{r}
library(VennDiagram)
library(grid)

#Load epigenetic clock CpGs.
Epigenetic_clocks_CpGs <- read.csv("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/Epigenetic_clocks_CpGs.csv",
                                     header = TRUE)
Epigenetic_clocks_CpGs[Epigenetic_clocks_CpGs==""] <- NA

DNAmHorvath <- na.omit(as.character(Epigenetic_clocks_CpGs$DNAmHorvath))
DNAmCortical <- na.omit(as.character(Epigenetic_clocks_CpGs$DNAmCortical))

#Make Venn diagram.
x <- list(DNAmHorvath, DNAmCortical)

setwd("~/KoborLab/kobor_space/kendrix/macular_degeneration/plots/")
futile.logger::flog.threshold(futile.logger::ERROR, name = "VennDiagramLogger")
venn_overlap <- venn.diagram(x = x, 
             category.names = c("DNAmHorvath" , "DNAmCortical"), 
             filename = NULL,
             cat.cex = 1, cat.fontface = "bold", cat.default.pos = "outer", 
             cat.pos = c(-25, 25),
             cat.dist = c(0.04, 0.04),
             scaled = FALSE
             )
grid.newpage()
grid.draw(venn_overlap) #5 overlapping CpGs. 

#Find out what the overlapping CpGs are. 
overlap_cpgs <- intersect(DNAmHorvath, DNAmCortical)

#Load 450K annotation data.
load("~/KoborLab/kobor_space/shared_coding_resource/Illumina_EPIC/EPIC_Annotation_Complete.RData")

EPIC_Annotation_Complete[which(EPIC_Annotation_Complete$Name %in% overlap_cpgs),]
EPIC_Annotation_Complete[which(EPIC_Annotation_Complete$Name %in% overlap_cpgs),]$UCSC_RefGene_Name
```


Find overlap between age-associated clock CpGs and EWAS hits.

```{r}
#Load epigenetic clock CpGs.
EWAS_hits <- read.csv("~/KoborLab/kobor_space/kendrix/macular_degeneration/data/EWAS_hits.csv", header = TRUE)

#Find overlap.
Epigenetic_clocks_CpGs[Epigenetic_clocks_CpGs$DNAmHorvath %in% EWAS_hits$EWAS_hits,]$DNAmHorvath
Epigenetic_clocks_CpGs[Epigenetic_clocks_CpGs$DNAmHannum %in% EWAS_hits$EWAS_hits,]$DNAmHannum
Epigenetic_clocks_CpGs[Epigenetic_clocks_CpGs$DNAmCortical %in% EWAS_hits$EWAS_hits,]$DNAmCortical
Epigenetic_clocks_CpGs[Epigenetic_clocks_CpGs$DNAmSkinBlood %in% EWAS_hits$EWAS_hits,]$DNAmSkinBlood
Epigenetic_clocks_CpGs[Epigenetic_clocks_CpGs$DNAmZhang %in% EWAS_hits$EWAS_hits,]$DNAmZhang
Epigenetic_clocks_CpGs[Epigenetic_clocks_CpGs$DNAmPhenoAge %in% EWAS_hits$EWAS_hits,]$DNAmPhenoAge
Epigenetic_clocks_CpGs[Epigenetic_clocks_CpGs$DNAmWeidner %in% EWAS_hits$EWAS_hits,]$DNAmWeidner
```


###Step 23: Prepare data for DNAmTL.

[DNAmTL](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6738410/) is a methylation estimator for telomere length based on 140CpGs. DNAmTL is said to be not only an epigenetic biomarker of replicative history of cells, but also a useful marker for age-related pathologies that are associated with it.

This script is used to do telomere length prediction based on Illumina 450K and EPIC DNA methylation data. Coefficients of the predictor are based on  training samples.

```{r}
#Subset relevant epigenetic age variables. 
AMD_Epigenetic_DNAmTL <- AMD_pData[, c("Sample_Name", "Sample_Group", "Array", "Slide", "Sex", "predictedGender", "Tissue", "predictedTissue", "Age", "DNAmTL")] 
```


###Step 24: DNAmTL predictor.

```{r, fig.align='center'}
#Create function to plot linear regression.
ggplotRegression <- function (fit) {

require(ggplot2)

ggplot(fit$model, aes_string(x = names(fit$model)[2], y = names(fit$model)[1])) + 
  geom_point(aes(colour = AMD_Epigenetic_DNAmTL$Sex, shape = AMD_Epigenetic_DNAmTL$Sample_Group)) +
  stat_smooth(method = "lm", col = "red") 
}

#Regression plot of Zhang clock predicted DNAmAge against reported age:
AMD_DNAmTL_plot <- lm(DNAmTL ~ Age, data = AMD_Epigenetic_DNAmTL)
ggplotRegression(AMD_DNAmTL_plot) + labs(x = "Reported age", y = "DNAm telomere length", caption = "Correlation between chronological age and predicted telomere length") + 
  scale_colour_manual(name = "Sex", values = c("#990000", "#2c7dab")) +
  scale_shape_manual(name = "Disease State", values = c(20, 23), labels = c("AMD", "Normal")) +
  stat_cor(method = "spearman") +
  theme_bw() + theme(panel.border = element_blank(), 
                     panel.grid.major = element_blank(), 
                     panel.grid.minor = element_blank(), 
                     axis.line = element_line(colour = "black"), 
                     axis.text = element_text(), 
                     axis.title = element_text(size = 8), 
                     plot.caption = element_text(hjust = 0.5, size = rel(1)))
```

```{r, fig.align='center'}
#Plot of overall disease state vs control:
AMD_Epigenetic_DNAmTL$Sample_Group <- factor(AMD_Epigenetic_DNAmTL$Sample_Group)
ggplot(data = AMD_Epigenetic_DNAmTL, 
       aes(x = Sample_Group, y = DNAmTL, fill = Sample_Group)) +
  geom_boxplot(position = position_dodge(0.7), width = 0.5, outlier.shape = NA) +
  geom_jitter(aes(fill = Sample_Group), size = 2, shape = 21, alpha = 0.7, 
              position = position_jitterdodge(dodge.width = 0.75, jitter.width = 0.3)) + 
  xlab("Disease State") + ylab("DNAmTL Prediction") + 
  scale_x_discrete(breaks = c("age-related macular degeneration","normal"), 
                   labels = c("Age-Related Macular Degeneration", "Normal")) + 
  scale_fill_manual(values = c("#77284e", "#ffffff")) +
  theme_classic() + theme(
              panel.border = element_blank(),
              panel.background = element_blank(),
              plot.title = element_text(size = 14, family = "Tahoma", face = "bold"),
              text = element_text(family = "Tahoma"),
              axis.title = element_text(face = "bold"),
              axis.text.x = element_text(colour = "black", size = 11),
              axis.text.y = element_text(colour = "black", size = 9),
              axis.line = element_line(size = 0.5, colour = "black"),
              legend.position = "none")
```

---------------------------------------------------------------------------------------------------------------------------


##References

Chen Y et al. (2013) Discovery of cross-reactive probes and polymorphic CpGs in the Illumina Infinium HumanMethylation450     microarray. Epigenetics.

Heiss J & Just JC (2019) Improved filtering of DNA methylation microarray data by detection *p* values and its impact on     downstream anayses. Clinical Epigenetics.

Heiss J & Just JC (2018) Identifying mislabeled and contaminated DNA methylation microarray data: an extended quality        control toolset with examples from GEO. Clinial Epigenetics. 












